<!DOCTYPE html>

<html>
	<head>
		<title></title>
        <script type="text/javascript" src="lightgl.js"></script>
        <style type="text/css">
        img {display:none}
        </style>
	</head>
    <body>
    
  <img id="tiles" src="tiles.jpg">
  <img id="xneg" src="xneg.jpg">
  <img id="xpos" src="xpos.jpg">
  <img id="ypos" src="ypos.jpg">
  <img id="zneg" src="zneg.jpg">
  <img id="zpos" src="zpos.jpg">
    
    	<script type="text/javascript">
              
        
        
            function text2html(text) {
  return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
}

function handleError(text) {
  var html = text2html(text);
  if (html == 'WebGL not supported') {
    html = 'Your browser does not support WebGL.<br>Please see\
    <a href="http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">\
    Getting a WebGL Implementation</a>.';
  }
  alert(html);
}

window.onerror = handleError;

var gl = GL.create();
var water;
var cubemap;
var renderer;
var angleX = -25;
var angleY = -200.5;

// Sphere physics info
var useSpherePhysics = false;
var center;
var oldCenter;
var velocity;
var gravity;
var radius;
var paused = false;

window.onload = function() {
  function onresize() {
    gl.canvas.width = window.innerWidth;
    gl.canvas.height = window.innerHeight;
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.matrixMode(gl.PROJECTION);
    gl.loadIdentity();
    gl.perspective(45, gl.canvas.width / gl.canvas.height, 0.01, 100);
    gl.matrixMode(gl.MODELVIEW);
    draw();
  }

  document.body.appendChild(gl.canvas);
  gl.clearColor(0, 0, 0, 0);

  water = new Water();
  renderer = new Renderer();
  cubemap = new Cubemap({
    xneg: document.getElementById('xneg'),
    xpos: document.getElementById('xpos'),
    yneg: document.getElementById('ypos'),
    ypos: document.getElementById('ypos'),
    zneg: document.getElementById('zneg'),
    zpos: document.getElementById('zpos')
  });

  if (!water.textureA.canDrawTo() || !water.textureB.canDrawTo()) {
    throw new Error('Rendering to floating-point textures is required but not supported');
  }

  center = oldCenter = new GL.Vector(-0.4, -0.75, 0.2);
  velocity = new GL.Vector();
  gravity = new GL.Vector(0, -4, 0);
  //球半径
  radius = 0.25;

  
  //初始化一些波纹
  for (var i = 0; i < 2 ; i++) {
    water.addDrop(Math.random() * 2 - 1, Math.random() * 2 - 1, 0.03, (i & 1) ? 0.01 : -0.01);
  }


  onresize();

  //考虑requestAnimationFrame的浏览器兼容性
  var requestAnimationFrame =
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    function(callback) { setTimeout(callback, 0); };

  var prevTime = new Date().getTime();
  function animate() {
    var nextTime = new Date().getTime();
    if (!paused) {
      update((nextTime - prevTime) / 1000);
      draw();
    }
    prevTime = nextTime;
    requestAnimationFrame(animate);
  }
  animate();

  window.onresize = onresize;

  var prevHit;
  var planeNormal;
  var mode = -1;
  var MODE_ADD_DROPS = 0;
  var MODE_MOVE_SPHERE = 1;
  var MODE_ORBIT_CAMERA = 2;

  var oldX, oldY;

  document.onmousedown = function(e) {
    oldX = e.pageX;
    oldY = e.pageY;
    var tracer = new GL.Raytracer();
    var ray = tracer.getRayForPixel(e.pageX, e.pageY);
    var pointOnPlane = tracer.eye.add(ray.multiply(-tracer.eye.y / ray.y));
    var sphereHitTest = GL.Raytracer.hitTestSphere(tracer.eye, ray, center, radius);
    if (sphereHitTest) {
      mode = MODE_MOVE_SPHERE;
      prevHit = sphereHitTest.hit;
      planeNormal = tracer.getRayForPixel(gl.canvas.width / 2, gl.canvas.height / 2).negative();
    } else if (Math.abs(pointOnPlane.x) < 1 && Math.abs(pointOnPlane.z) < 1) {
      mode = MODE_ADD_DROPS;
      document.onmousemove(e);
    } else {
      mode = MODE_ORBIT_CAMERA;
    }
  };

  document.onmouseup = function(e) {
    mode = -1;
  };

  
  //鼠标事件
  document.onmousemove = function(e) {
    switch (mode) {
    //产生水波
      case MODE_ADD_DROPS:
        var tracer = new GL.Raytracer();
        var ray = tracer.getRayForPixel(e.pageX, e.pageY);
        var pointOnPlane = tracer.eye.add(ray.multiply(-tracer.eye.y / ray.y));
        water.addDrop(pointOnPlane.x, pointOnPlane.z, 0.03, 0.01);
        if (paused) {
          water.updateNormals();
          renderer.updateCaustics(water);
        }
        break;
        //移动球
      case MODE_MOVE_SPHERE:
        var tracer = new GL.Raytracer();
        var ray = tracer.getRayForPixel(e.pageX, e.pageY);
        var t = -planeNormal.dot(tracer.eye.subtract(prevHit)) / planeNormal.dot(ray);
        var nextHit = tracer.eye.add(ray.multiply(t));
        center = center.add(nextHit.subtract(prevHit));
        center.x = Math.max(radius - 1, Math.min(1 - radius, center.x));
        center.y = Math.max(radius - 1, Math.min(10, center.y));
        center.z = Math.max(radius - 1, Math.min(1 - radius, center.z));
        prevHit = nextHit;
        if (paused) renderer.updateCaustics(water);
        break;
        //旋转镜头
      case MODE_ORBIT_CAMERA:
        angleY -= e.pageX - oldX;
        angleX -= e.pageY - oldY;
 //       angleX = Math.max(-90, Math.min(90, angleX));
        break;
    }
    oldX = e.pageX;
    oldY = e.pageY;
    if (paused) draw();
  };
    //键盘事件   //charCodeAt方法可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。
  document.onkeydown = function(e) {
 //   console.dir(e);
    if (e.which == ' '.charCodeAt(0)) paused = !paused;
    else if (e.which == 'G'.charCodeAt(0)) useSpherePhysics = !useSpherePhysics;
    else if (e.which == 'L'.charCodeAt(0) && paused) draw();
  };

  

  function update(seconds) {
     if (seconds > 1) return;

    if (mode == MODE_MOVE_SPHERE) {
      // Start from rest when the player releases the mouse after moving the sphere
      velocity = new GL.Vector();
    } else if (useSpherePhysics) {
      // Fall down with viscosity under water
      //计算球下落到水中的效果轨迹
      var percentUnderWater = Math.max(0, Math.min(1, (radius - center.y) / (2 * radius)));
    velocity = velocity.add(gravity.multiply(seconds - 1.1 * seconds * percentUnderWater));
      velocity = velocity.subtract(velocity.unit().multiply(percentUnderWater * seconds * velocity.dot(velocity)));
     center = center.add(velocity.multiply(seconds));

      // Bounce off the bottom，球落下碰到水池底的效果
      //水平面的y坐标为0，水深为1.
      if (center.y < radius - 1) {
        center.y = radius - 1;
        velocity.y = Math.abs(velocity.y) * 0.7;
      }
    }

    // Displace water around the sphere, 模拟球和水接触效果
    water.moveSphere(oldCenter, center, radius);
    oldCenter = center;

    // Update the water simulation and graphics
    //生成水波纹效果
 //  water.stepSimulation();
  // water.stepSimulation();
   water.stepSimulation();
  water.updateNormals();
   //绘制水底光线倒影
    renderer.updateCaustics(water);
  }

  function draw() {
    // Change the light direction to the camera look vector when the L key is pressed
    if (GL.keys.L) {
      renderer.lightDir = GL.Vector.fromAngles((90 - angleY) * Math.PI / 180, -angleX * Math.PI / 180);
     if (paused) renderer.updateCaustics(water);
    }

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.loadIdentity();
    //物体变换顺序与代码顺序相反
    gl.translate(0, 0, -4);
    gl.rotate(-angleX, 1, 0, 0);
    gl.rotate(-angleY, 0, 1, 0);
    gl.translate(0, 0.5, 0);

    //绘制物体
    gl.enable(gl.DEPTH_TEST);
    renderer.sphereCenter = center;
    renderer.sphereRadius = radius;
    renderer.renderCube();
    renderer.renderWater(water, cubemap);
 //   renderer.renderSphere();
    gl.disable(gl.DEPTH_TEST);
  }
};




       
// The data in the texture is (position.y, velocity.y, normal.x, normal.z)
function Water() {
  var vertexShader = '\
    varying vec2 coord;\
    void main() {\
      coord = gl_Vertex.xy * 0.5 + 0.5;\
      gl_Position = vec4(gl_Vertex.xyz, 1.0);\
    }\
  ';
  this.plane = GL.Mesh.plane();
  if (!GL.Texture.canUseFloatingPointTextures()) {
    throw new Error('This demo requires the OES_texture_float extension');
  }
  var filter = GL.Texture.canUseFloatingPointLinearFiltering() ? gl.LINEAR : gl.NEAREST;
  this.textureA = new GL.Texture(256, 256, { type: gl.FLOAT, filter: filter });
  this.textureB = new GL.Texture(256, 256, { type: gl.FLOAT, filter: filter });
  this.dropShader = new GL.Shader(vertexShader, [
    "const float PI = 3.141592653589793;",
    "uniform sampler2D texture1;",
 
    "uniform vec2 center;",    //点击的点
    "uniform float radius;",     //振动的周长
    "uniform float strength;",   //振幅强度
    "varying vec2 coord;",
    "void main() {",
      /* get vertex info */
     " vec4 info = texture2D(texture1, coord);",
      
      /* add the drop to the height */
      "float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);",
      "drop = 0.5 - cos(drop * PI) * 0.5;",
      "info.r += drop * strength;",
      
      "gl_FragColor = info;",
    "}"
  ].join(""));
  this.updateShader = new GL.Shader(vertexShader, [
    "uniform sampler2D texture;",
    "uniform vec2 delta;",
    "varying vec2 coord;",
    "void main() {",
      /* get vertex info */
      "vec4 info = texture2D(texture, coord);",
      
      /* calculate average neighbor height */  //coord处平均高度
      "vec2 dx = vec2(delta.x, 0.0);",
      "vec2 dy = vec2(0.0, delta.y);",
      "float average = (",
        "texture2D(texture, coord - dx).r +",
        "texture2D(texture, coord - dy).r +",
        "texture2D(texture, coord + dx).r +",
        "texture2D(texture, coord + dy).r",
      ") * 0.25;",
      
      /* change the velocity to move toward the average */
      "info.g += (average - info.r) * 2.0;",
      
      /* attenuate the velocity a little so waves do not last forever */
     "info.g *= 0.995;",
      
      /* move the vertex along the velocity */
      "info.r += info.g;",
      
      "gl_FragColor = info;",
    "}"
  ].join(""));
  this.normalShader = new GL.Shader(vertexShader, [
    "uniform sampler2D texture;",
    "uniform vec2 delta;",
    "varying vec2 coord;",
    "void main() {",
      /* get vertex info */
      "vec4 info = texture2D(texture, coord);",
      
      /* update the normal */
      "vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);",
      "vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);",
      "info.ba = normalize(cross(dy, dx)).xz;",
      
      "gl_FragColor = info;",
    "}"
  ].join(""));
  //球与水面接触的效果
  this.sphereShader = new GL.Shader(vertexShader, [
    "uniform sampler2D texture;",
    "uniform vec3 oldCenter;",
    "uniform vec3 newCenter;",
    "uniform float radius;",
    "varying vec2 coord;",
    
    "float volumeInSphere(vec3 center) {",
      "vec3 toCenter = vec3(coord.x * 2.0 - 1.0, 0.0, coord.y * 2.0 - 1.0) - center;",
      "float t = length(toCenter) / radius;",
      "float dy = exp(-pow(t * 1.5, 6.0));",
      "float ymin = min(0.0, center.y - dy);",
      "float ymax = min(max(0.0, center.y + dy), ymin + 2.0 * dy);",
      "return (ymax - ymin) * 0.1;",
    "}",
    
    "void main() {",
      /* get vertex info */
      "vec4 info = texture2D(texture, coord);",
      
      /* add the old volume */
      "info.r += volumeInSphere(oldCenter);",
      
      /* subtract the new volume */
      "info.r -= volumeInSphere(newCenter);",
      
      "gl_FragColor = info;",
   "}"
  ].join(""));
}

Water.prototype.addDrop = function(x, y, radius, strength) {
  var this_ = this;
  this.textureB.drawTo(function() {
    this_.textureA.bind();
    this_.dropShader.uniforms({
      center: [x, y],
      radius: radius,
      strength: strength,
    }).draw(this_.plane);

  });
  this.textureB.swapWith(this.textureA);
};

Water.prototype.stepSimulation = function() {
  var this_ = this;
  this.textureB.drawTo(function() {
    this_.textureA.bind();
    this_.updateShader.uniforms({
      delta: [1 / this_.textureA.width, 1 / this_.textureA.height]
    }).draw(this_.plane);
  });
  this.textureB.swapWith(this.textureA);
};

Water.prototype.updateNormals = function() {
  var this_ = this;
  this.textureB.drawTo(function() {
    this_.textureA.bind();
    this_.normalShader.uniforms({
      delta: [1 / this_.textureA.width, 1 / this_.textureA.height]
    }).draw(this_.plane);
  });
  this.textureB.swapWith(this.textureA);
};


Water.prototype.moveSphere = function(oldCenter, newCenter, radius) {
  var this_ = this;
  this.textureB.drawTo(function() {
    this_.textureA.bind();
    this_.sphereShader.uniforms({
      oldCenter: oldCenter,
      newCenter: newCenter,
      radius: radius
    }).draw(this_.plane);
  });
  this.textureB.swapWith(this.textureA);
};






//一些着色器的函数
var helperFunctions = [
 "const float IOR_AIR = 1.0;",
  "const float IOR_WATER = 1.333;",
  "const vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);",
  "const vec3 underwaterColor = vec3(0.4, 0.9, 1.0);",
  "const float poolHeight = 1.0;",
  "uniform vec3 light;",
  "uniform vec3 sphereCenter;",
  "uniform float sphereRadius;",
  "uniform sampler2D tiles;",
  "uniform sampler2D causticTex;",
  "uniform sampler2D water;",
  
  "vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {",
    "vec3 tMin = (cubeMin - origin) / ray;",   //时间
    "vec3 tMax = (cubeMax - origin) / ray;",
    "vec3 t1 = min(tMin, tMax);",
    "vec3 t2 = max(tMin, tMax);",
    "float tNear = max(max(t1.x, t1.y), t1.z);",
    "float tFar = min(min(t2.x, t2.y), t2.z);",
    "return vec2(tNear, tFar);",
  "}",
  
  "float intersectSphere(vec3 origin, vec3 ray, vec3 sphereCenter, float sphereRadius) {",
    "vec3 toSphere = origin - sphereCenter;",
    "float a = dot(ray, ray);",
    "float b = 2.0 * dot(toSphere, ray);",
    "float c = dot(toSphere, toSphere) - sphereRadius * sphereRadius;",
    "float discriminant = b*b - 4.0*a*c;",
    "if (discriminant > 0.0) {",
      "float t = (-b - sqrt(discriminant)) / (2.0 * a);",
     " if (t > 0.0) return t;",
    "}",
    "return 1.0e6;",
  "}",
  
  "vec3 getSphereColor(vec3 point) {",   //point 球面上的点
    "vec3 color = vec3(0.5);",
    
    /* ambient occlusion with walls */ //环境光衰减？
    "color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.x)) / sphereRadius, 3.0);",
   "color *= 1.0 - 0.9 / pow((1.0 + sphereRadius - abs(point.z)) / sphereRadius, 3.0);",
    "color *= 1.0 - 0.9 / pow((point.y + 1.0 + sphereRadius) / sphereRadius, 3.0);",
    
    /* caustics */  //从水面上看球表面的焦散效果
    "vec3 sphereNormal = (point - sphereCenter) / sphereRadius;",
    "vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);",   //计算折射光线
    "float diffuse = max(0.0, dot(-refractedLight, sphereNormal)) * 0.5;",  //漫反射
    "vec4 info = texture2D(water, point.xz * 0.5 + 0.5);",
    "if (point.y < info.r) {",
      "vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);",
      "diffuse *= caustic.r * 4.0;",
    "}",
    "color += diffuse;",
    
    "return color;",
  "}",
  
  "vec3 getWallColor(vec3 point) {",   // point墙壁上的点
    "float scale = 0.5;",
    
    "vec3 wallColor;",
    "vec3 normal;",
    "if (abs(point.x) > 0.999) {",
        //左右墙壁
      "wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;",
      "normal = vec3(-point.x, 0.0, 0.0);",
    "} else if (abs(point.z) > 0.999) {",
        //前后墙壁
      "wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;",
      "normal = vec3(0.0, 0.0, -point.z);",
    "} else {",
        //水下墙壁
     //   "wallColor = vec3(1.0,0.0,0.0 );",
      "wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;",
      "normal = vec3(0.0, 1.0, 0.0);",
    "}",
    
    "scale /= length(point);", /* pool ambient occlusion */  //光在水池中衰减
   "scale *= 1.0 - 0.9 / pow(length(point - sphereCenter) / sphereRadius, 4.0);", /* sphere ambient occlusion */    //光被球遮挡后衰减
    
    /* caustics */  //水下焦散光线
    "vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);",
    "float diffuse = max(0.0, dot(refractedLight, normal));",
    "vec4 info = texture2D(water, point.xz * 0.5 + 0.5);",
   "if (point.y < info.r) {",
        //水池水下部分
     "vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);",
      "scale += diffuse * caustic.r * 2.0 * caustic.g;",
    "} else {",
      /* shadow for the rim of the pool */   //水池边,未接触水
     "vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));",
     "diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));",
      
     " scale += diffuse * 0.5;",
    "}",
    
    "return wallColor * scale;",
  "}"
].join("");

function Renderer() {
        //水池墙壁纹理
  this.tileTexture = GL.Texture.fromImage(document.getElementById('tiles'), {
    minFilter: gl.LINEAR_MIPMAP_LINEAR,
    wrap: gl.REPEAT,
    format: gl.RGB
  });
  //光线方向
  this.lightDir = new GL.Vector(2.0, 2.0, -1.0).unit();
  //焦散纹理
  this.causticTex = new GL.Texture(1024, 1024);
  //水下折射平面
  this.waterMesh = GL.Mesh.plane({ detail: 200 });
  
  this.waterShaders = [];
  for (var i = 0; i < 2; i++) {
    this.waterShaders[i] = new GL.Shader([
      "uniform sampler2D water;",
      "varying vec3 position;",
      "void main() {",
        "vec4 info = texture2D(water, gl_Vertex.xy * 0.5 + 0.5);",
        "position = gl_Vertex.xzy;",
        //控制水的波纹
        "position.y += info.r;",
       " gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);",
      "}"
    ].join(""), helperFunctions + [
      "uniform vec3 eye;",
      "varying vec3 position;",
      "uniform samplerCube sky;",
      //获得水面颜色
      "vec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {",
        "vec3 color;",
        "float q = intersectSphere(origin, ray, sphereCenter, sphereRadius);",
        "if (q < 1.0e6)  {",  // 从上看水中球的颜色
          "color = getSphereColor(origin + ray * q);",
        "} else if (ray.y < 0.0) {",
        //水中墙壁颜色
          "vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));",
        "color = getWallColor(origin + ray * t.y);",
        "} else {",
          "vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));",
          "vec3 hit = origin + ray * t.y;",
         "if (hit.y < 2.0 / 12.0) {",
       //  水池边缘倒影
            "color = getWallColor(hit);",
          "} else {",  
            //天空倒影
           "color = textureCube(sky, ray).rgb;",
            "color += vec3(pow(max(0.0, dot(light, ray)), 5000.0)) * vec3(10.0, 8.0, 6.0);",
         "}",
        "}",
       "if (ray.y < 0.0) color *= waterColor;",
        "return color;",
      "}",
      
      "void main() {",
       " vec2 coord = position.xz * 0.5 + 0.5;",
        "vec4 info = texture2D(water, coord);",
        
        /* make water look more "peaked" */
        "for (int i = 0; i < 5; i++) {",
        " coord += info.ba * 0.005;",
         "info = texture2D(water, coord);",
        "}",
        
        "vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);",
        "vec3 incomingRay = normalize(position - eye);"].join("")
        
         + (i ? /* underwater */ 
         [ "normal = -normal;",
          "vec3 reflectedRay = reflect(incomingRay, normal);",       //反射光线
          "vec3 refractedRay = refract(incomingRay, normal, IOR_WATER / IOR_AIR);",   //折射光线
          "float fresnel = mix(0.5, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));",     //菲涅尔系数 
          
          "vec3 reflectedColor = getSurfaceRayColor(position, reflectedRay, underwaterColor);",
          "vec3 refractedColor = getSurfaceRayColor(position, refractedRay, vec3(1.0)) * vec3(0.8, 1.0, 1.1);",
          //菲涅尔方程
          "gl_FragColor = vec4(mix(reflectedColor, refractedColor , (1.0 - fresnel) * length(refractedRay)), 1.0);"
          ].join("")  
            : /* above water */ [
          "vec3 reflectedRay = reflect(incomingRay, normal);",        //反射光线
          "vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);",       //折射光线  
          "float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));",
          
          "vec3 reflectedColor = getSurfaceRayColor(position, reflectedRay, abovewaterColor);",
          "vec3 refractedColor = getSurfaceRayColor(position, refractedRay, abovewaterColor);",
          
          "gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);"].join("")
        ) + '}'
        );
  }
  
  //球
  this.sphereMesh = GL.Mesh.sphere({ detail: 100 });
  this.sphereShader = new GL.Shader(helperFunctions + '\
    varying vec3 position;\
    void main() {\
      position = sphereCenter + gl_Vertex.xyz * sphereRadius;\
      gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);\
    }\
  ', helperFunctions + '\
    varying vec3 position;\
    void main() {\
      gl_FragColor = vec4(getSphereColor(position), 1.0);\
      vec4 info = texture2D(water, position.xz * 0.5 + 0.5);\
      if (position.y < info.r) {\
        gl_FragColor.rgb *= underwaterColor * 1.2;\
      }\
    }\
  ');
  
  //泳池的立方体
  this.cubeMesh = GL.Mesh.cube();
  this.cubeMesh.triangles.splice(4, 2);
  this.cubeMesh.compile();
  this.cubeShader = new GL.Shader(helperFunctions + '\
    varying vec3 position;\
    void main() {\
      position = gl_Vertex.xyz;\
      position.y = ((1.0 - position.y) * (7.0 / 12.0) - 1.0) * poolHeight;\
      gl_Position = gl_ModelViewProjectionMatrix * vec4(position, 1.0);\
    }\
  ', helperFunctions + '\
    varying vec3 position;\
    void main() {\
      gl_FragColor = vec4(getWallColor(position), 1.0);\
      vec4 info = texture2D(water, position.xz * 0.5 + 0.5);\
      if (position.y < info.r) {\
        gl_FragColor.rgb *= underwaterColor * 1.2;\
      }\
    }\
  ');
  
  //焦散shader
  this.sphereCenter = new GL.Vector();
  this.sphereRadius = 0.25;
  var hasDerivatives = !!gl.getExtension('OES_standard_derivatives');
  this.causticsShader = new GL.Shader(helperFunctions + [
    "varying vec3 oldPos;",
    "varying vec3 newPos;",
    "varying vec3 ray;",
    
    /* project the ray onto the plane */   //映射水面的点到泳池
    "vec3 project(vec3 origin, vec3 ray, vec3 refractedLight) {",
      "vec2 tcube = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));",
      "origin += ray * tcube.y;",
      "float tplane = (-origin.y - 1.0) / refractedLight.y;",  //到泳池侧壁的时间
      "return origin  + refractedLight * tplane;",
    "}",
    
    "void main() {",
      "vec4 info = texture2D(water, gl_Vertex.xy * 0.5 + 0.5);",
      "info.ba *= 0.5;",
      "vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);",
      
      /* project the vertices along the refracted vertex ray */
      //折射光线
      "vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);",
      //折射后的视线
      "ray = refract(-light, normal, IOR_AIR / IOR_WATER);",
      //无波纹的位置
      "oldPos = project(gl_Vertex.xzy, refractedLight, refractedLight);",
      //有波纹的位置
      "newPos = project(gl_Vertex.xzy + vec3(0.0, info.r, 0.0), ray, refractedLight);",
       
      "gl_Position = vec4(0.75 * (newPos.xz + refractedLight.xz / refractedLight.y), 0.0, 1.0);",
    "}"
  ].join(""), (hasDerivatives ? '#extension GL_OES_standard_derivatives : enable\n' : '') + 
    helperFunctions + [
    "varying vec3 oldPos;",
    "varying vec3 newPos;",
    "varying vec3 ray;",
    
    "void main() {"].join("")
       + (hasDerivatives ? 
        /* if the triangle gets smaller, it gets brighter, and vice versa */
        "float oldArea = length(dFdx(oldPos)) * length(dFdy(oldPos));" +
        "float newArea = length(dFdx(newPos)) * length(dFdy(newPos));" +
       "gl_FragColor = vec4(oldArea / newArea * 0.2, 1.0, 0.0, 0.0);"
       : 
        "gl_FragColor = vec4(0.2, 0.2, 0.0, 0.0);"
       ) + [
      "vec3 refractedLight = refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);",
      
      /* compute a blob shadow and make sure we only draw a shadow if the player is blocking the light */
      //球在挡住光线后只画阴影
      "vec3 dir = (sphereCenter - newPos) / sphereRadius;",
      "vec3 area = cross(dir, refractedLight);",
      "float shadow = dot(area, area);",
      "float dist = dot(dir, -refractedLight);",
      "shadow = 1.0 + (shadow - 1.0) / (0.05 + dist * 0.025);",
      "shadow = clamp(1.0 / (1.0 + exp(-shadow)), 0.0, 1.0);",
      "shadow = mix(1.0, shadow, clamp(dist * 2.0, 0.0, 1.0));",
  //    "gl_FragColor.g = shadow;",
      
      /* shadow for the rim of the pool */ //水池边的阴影
      "vec2 t = intersectCube(newPos, -refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));",
     "gl_FragColor.r *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (newPos.y - refractedLight.y * t.y - 2.0 / 12.0)));",
    "}"
  ].join(""));
}

//制造水底的焦散效果
Renderer.prototype.updateCaustics = function(water) {
  if (!this.causticsShader) return;
  var this_ = this;
  this.causticTex.drawTo(function() {
    gl.clear(gl.COLOR_BUFFER_BIT);
    water.textureA.bind(0);
    this_.causticsShader.uniforms({
      light: this_.lightDir,
      water: 0,
    sphereCenter: this_.sphereCenter,
    sphereRadius: this_.sphereRadius
    }).draw(this_.waterMesh);
  });
};

//绘制水面
Renderer.prototype.renderWater = function(water, sky) {
  var tracer = new GL.Raytracer();
 water.textureA.bind(0);
  this.tileTexture.bind(1);
  sky.bind(2);
  this.causticTex.bind(3);
  gl.enable(gl.CULL_FACE);
  for (var i = 0; i < 2; i++) {
    gl.cullFace(i ? gl.BACK : gl.FRONT);
    this.waterShaders[i].uniforms({
    light: this.lightDir,
   water: 0,
    tiles: 1,
    sky: 2,
    causticTex: 3,  //水面上的焦散效果
      eye: tracer.eye,
      sphereCenter: this.sphereCenter,
     sphereRadius: this.sphereRadius
    }).draw(this.waterMesh);
  }
  gl.disable(gl.CULL_FACE);
};

//绘制球体
Renderer.prototype.renderSphere = function() {
  water.textureA.bind(0);
  this.causticTex.bind(1);
  this.sphereShader.uniforms({
    light: this.lightDir,
   water: 0,
    causticTex: 1,
    sphereCenter: this.sphereCenter,
    sphereRadius: this.sphereRadius
  }).draw(this.sphereMesh);
};

//绘制池子
Renderer.prototype.renderCube = function() {
  gl.enable(gl.CULL_FACE);
  water.textureA.bind(0);
  this.tileTexture.bind(1);
  this.causticTex.bind(2);
  this.cubeShader.uniforms({
    light: this.lightDir,
   water: 0,
    tiles: 1,
  causticTex: 2,
    sphereCenter: this.sphereCenter,
    sphereRadius: this.sphereRadius
  }).draw(this.cubeMesh);
  gl.disable(gl.CULL_FACE);
};






//水面的立方阴影倒影
function Cubemap(images) {
  this.id = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.id);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, images.xneg);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, images.xpos);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, images.yneg);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, images.ypos);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, images.zneg);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, images.zpos);
}

Cubemap.prototype.bind = function(unit) {
    gl.activeTexture(gl.TEXTURE0 + (unit || 0));
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.id);
};

Cubemap.prototype.unbind = function(unit) {
    gl.activeTexture(gl.TEXTURE0 + (unit || 0));
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
};
      
   
        </script>
    </body>
</html>