<!DOCTYPE html>
<html >
<head>
<title>example</title>
</head>
<body style="margin: 10px">
<canvas width="1024px" height="600px" id="canvas"></canvas>

<script src="./matrixLibs.js"></script>
<script type="text/javascript">
	const canvas = document.getElementById("canvas");
	const gl = canvas.getContext("webgl",  {antialias: true});	

  let AMORTIZATION=0.9; //折旧系数。【0, 1】，0表示无穷大阻力，1表示没有阻力
	let drag = false;
	let oldPosition=[0, 0];

	const mouseDown = function (event) {
		event.preventDefault();
		drag = true;
		oldPosition[0] = event.clientX;
		oldPosition[1] = event.clientY;
	};
	const mouseUp = function () {
		drag = false;
	}
	let dX=0, dY=0;
	const mouseMove = function (event) {
		if (!drag) return false;
		event.preventDefault();

		dX=(event.clientX-oldPosition[0])/canvas.width * 2*Math.PI ;
		dY=(event.clientY-oldPosition[1])/canvas.height * 2*Math.PI ;
	 theta+=dX;
	 phi+=dY;
		oldPosition[0]=event.clientX, oldPosition[1]=event.clientY;
	}
	canvas.addEventListener("mousedown", mouseDown, false);
	canvas.addEventListener("mouseup", mouseUp, false);
	canvas.addEventListener("mouseout", mouseUp, false);
	canvas.addEventListener("mousemove", mouseMove, false);

	const vertexShader = `
		attribute vec3 position; //the position of the point
		attribute vec3 color; //点的颜色（R,G,B）
		uniform mat4 Pmatrix; //uniform变量的值在渲染中不变
		uniform mat4 Mmatrix; //模型变换矩阵：平移+旋转+缩放
		uniform mat4 Vmatrix; //视图变换矩阵：平移+旋转

		varying vec3 vColor; //用于将颜色传递到片元着色器

		void main(void) { //pre-built function
			gl_Position = Pmatrix * Vmatrix * Mmatrix * vec4(position, 1.0);  //矩阵运算在GPU中比在CPU中快得多。
			vColor = color; //vColor是顶点之间的差值
		}
	`;
	const fragmentShader = `
		precision mediump float; 

		varying vec3 vColor; //对应顶点着色器的vColor

		void main(void) {
			gl_FragColor = vec4(vColor, 1.);  //black
		}	
	`;

	const compileShader = function (source, type) {
		const shader = gl.createShader(type);
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			alert("ERROR IN "+ type + " SHADER : " + gl.getShaderInfoLog(shader));
			return false;
		}
		return shader;
	}

	let vShader = compileShader(vertexShader, gl.VERTEX_SHADER);
	let fShader = compileShader(fragmentShader, gl.FRAGMENT_SHADER);

	const shaderProgram = gl.createProgram();  
	gl.attachShader(shaderProgram, vShader);
	gl.attachShader(shaderProgram, fShader);
	
	gl.linkProgram(shaderProgram); 

	const Pmatrix = gl.getUniformLocation(shaderProgram, 'Pmatrix'); 
	const Mmatrix = gl.getUniformLocation(shaderProgram, 'Mmatrix');
	const Vmatrix = gl.getUniformLocation(shaderProgram, 'Vmatrix');

	let color = gl.getAttribLocation(shaderProgram, 'color');
	let position = gl.getAttribLocation(shaderProgram, 'position');
	gl.enableVertexAttribArray(color);
	gl.enableVertexAttribArray(position);  

	gl.useProgram(shaderProgram);  

	//顶点坐标数组, 这里的顺序不重要
	const triangleVertex =
	[
		-1,-1,-1,     1,1,0,
		1,-1,-1,     1,1,0,
		1, 1,-1,     1,1,0,
		-1, 1,-1,     1,1,0,

		-1,-1, 1,     0,0,1,
		1,-1, 1,     0,0,1,
		1, 1, 1,     0,0,1,
		-1, 1, 1,     0,0,1,

		-1,-1,-1,     0,1,1,
		-1, 1,-1,     0,1,1,
		-1, 1, 1,     0,1,1,
		-1,-1, 1,     0,1,1,

		1,-1,-1,     1,0,0,
		1, 1,-1,     1,0,0,
		1, 1, 1,     1,0,0,
		1,-1, 1,     1,0,0,

		-1,-1,-1,     1,0,1,
		-1,-1, 1,     1,0,1,
		1,-1, 1,     1,0,1,
		1,-1,-1,     1,0,1,

		-1, 1,-1,     0,1,0,
		-1, 1, 1,     0,1,0,
		1, 1, 1,     0,1,0,
		1, 1,-1,     0,1,0
  ];

	const pointBuffer = gl.createBuffer();  
	gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer); 
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleVertex), gl.STATIC_DRAW); 

	//顶点渲染顺序，这里指定顺序
	const triangleFaces = 
	[
		0,1,2,
		0,2,3,

		4,5,6,
		4,6,7,

		8,9,10,
		8,10,11,

		12,13,14,
		12,14,15,

		16,17,18,
		16,18,19,

		20,21,22,
		20,22,23
  ];
	const faceBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer); 
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(triangleFaces), gl.STATIC_DRAW);

 	const projMatrix = LIBS.get_projection(40, canvas.width/canvas.height, 1, 100);
 	const moveMatrix = LIBS.get_I4();  
	 const viewMatrix = LIBS.get_I4();
	
		

		let theta = 0;
		let phi = 0; 


	//渲染
	gl.clearColor(0, 0, 0, 0);

	gl.enable(gl.DEPTH_TEST);  
	gl.depthFunc(gl.LEQUAL);  
	gl.clearDepth(1.0);  

	let oldTime = 0;
	const animate = function (time) {
		//运动
		let dAngle=(time-oldTime);
		  if (!drag) {
			dX*=AMORTIZATION;
			dY*=AMORTIZATION;
			theta+=dX;
			phi+=dY;
		}
		LIBS.set_I4(moveMatrix);
		LIBS.scaleX(moveMatrix, 0.5);
		LIBS.scaleY(moveMatrix, 0.5);
		LIBS.scaleZ(moveMatrix, 0.5);
		// LIBS.rotateY(moveMatrix, theta);
		// LIBS.rotateX(moveMatrix, phi); 
		LIBS.set_I4(viewMatrix);
		LIBS.translateZ(viewMatrix, -5); 

		// OpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机
		 LIBS.rotateY(viewMatrix, -theta);
		 LIBS.rotateX(viewMatrix, -phi); 

		oldTime=time;
		
		gl.viewport(0, 0, canvas.width, canvas.height); 
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 
		gl.uniformMatrix4fv(Pmatrix, false, projMatrix); 
		gl.uniformMatrix4fv(Mmatrix, false, moveMatrix);
		gl.uniformMatrix4fv(Vmatrix, false, viewMatrix);

		//draw
		gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
		gl.vertexAttribPointer(position, 3, gl.FLOAT, gl.FALSE, 4*(3+3), 0); 
		gl.vertexAttribPointer(color, 3, gl.FLOAT, gl.FALSE, 4*(3+3), 3*4 );  

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer);
		gl.drawElements(gl.TRIANGLES, 3*2*6, gl.UNSIGNED_SHORT, 0);  

		gl.flush();  


		requestAnimationFrame(animate);  
	}

	animate(0);
</script>
</body>
</html>