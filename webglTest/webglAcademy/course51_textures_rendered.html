<!DOCTYPE html>
<html >
<head>
<title>example</title>
</head>
<body style="margin: 10px">
<canvas width="1024px" height="600px" id="canvas"></canvas>

<script src="./matrixLibs.js"></script>
<script type="text/javascript">
	const canvas = document.getElementById("canvas");
	const gl = canvas.getContext("webgl",  {antialias: true});	

  	let AMORTIZATION=0.9;  
	let drag = false;
	let oldPosition=[0, 0];

	const mouseDown = function (event) {
		event.preventDefault();
		drag = true;
		oldPosition[0] = event.clientX;
		oldPosition[1] = event.clientY;
	};
	const mouseUp = function () {
		drag = false;
	}
	let dX=0, dY=0;
	const mouseMove = function (event) {
		if (!drag) return false;
		event.preventDefault();

		dX=(event.clientX-oldPosition[0])/canvas.width * 2*Math.PI ;
		dY=(event.clientY-oldPosition[1])/canvas.height * 2*Math.PI ;
	 theta+=dX;
	 phi+=dY;
		oldPosition[0]=event.clientX, oldPosition[1]=event.clientY;
	}
	canvas.addEventListener("mousedown", mouseDown, false);
	canvas.addEventListener("mouseup", mouseUp, false);
	canvas.addEventListener("mouseout", mouseUp, false);
	canvas.addEventListener("mousemove", mouseMove, false);

	const vertexShader = `
		attribute vec3 position; //the position of the point
		attribute vec2 uv;

		uniform mat4 Pmatrix; 
		uniform mat4 Mmatrix; 
		uniform mat4 Vmatrix; 


		varying vec2 vuv; 

		void main(void) { //pre-built function
			gl_Position = Pmatrix * Vmatrix * Mmatrix * vec4(position, 1.0);  //矩阵运算在GPU中比在CPU中快得多。
			vuv = uv;
		}
	`;
	const fragmentShader = `
		precision mediump float; 

		uniform sampler2D sampler;
		varying vec2 vuv;

		void main(void) {
			gl_FragColor = texture2D(sampler, vuv); 
		}	
	`;

	const compileShader = function (source, type) {
		const shader = gl.createShader(type);
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			alert("ERROR IN "+ type + " SHADER : " + gl.getShaderInfoLog(shader));
			return false;
		}
		return shader;
	}

	let vShader = compileShader(vertexShader, gl.VERTEX_SHADER);
	let fShader = compileShader(fragmentShader, gl.FRAGMENT_SHADER);

	const shaderProgram = gl.createProgram();  
	gl.attachShader(shaderProgram, vShader);
	gl.attachShader(shaderProgram, fShader);
	
	gl.linkProgram(shaderProgram); 

	const Pmatrix = gl.getUniformLocation(shaderProgram, 'Pmatrix'); 
	const Mmatrix = gl.getUniformLocation(shaderProgram, 'Mmatrix');
	const Vmatrix = gl.getUniformLocation(shaderProgram, 'Vmatrix');
	const sampler = gl.getUniformLocation(shaderProgram, 'sampler');
	
	let uv = gl.getAttribLocation(shaderProgram, 'uv');
	let position = gl.getAttribLocation(shaderProgram, 'position');
	gl.enableVertexAttribArray(uv);
	gl.enableVertexAttribArray(position);  

	gl.useProgram(shaderProgram);  

 const getTexture=function(image_URL){
    const image=new Image();
    image.src=image_URL;
    image.webglTexture=false;
    image.onload=function(e) {
      const texture=gl.createTexture();              
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);  
      gl.bindTexture(gl.TEXTURE_2D, texture);     
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);  
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); 
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR); 
	  gl.generateMipmap(gl.TEXTURE_2D);  
      gl.bindTexture(gl.TEXTURE_2D, null); 
      image.webglTexture=texture;
    };

    return image;
  };
  //纹理对象
	gl.uniform1i(sampler, 0);
   const cubeTexture=getTexture("./texture.png");
	
   //渲染纹理
   const fb = gl.createFramebuffer();  //新建并初始化一个WebGLFramebuffer（作为渲染内容的缓存）.帧缓存
   gl.bindFramebuffer(gl.FRAMEBUFFER, fb);

  const rb=gl.createRenderbuffer();  //WebGLRenderbuffer用于存储图像数据，或作为渲染操作的对象。
  gl.bindRenderbuffer(gl.RENDERBUFFER, rb);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16 , 512, 512);  
//void gl.renderbufferStorage(target, internalFormat, width, height); 新建并初始化Renderbuffer对象的数据存储
	// target：指定Renderbuffer对象目标，gl.RENDERBUFFER: 单个图像的缓存数据存储以可渲染的内部各式.
	//internalFormat: 指定renderbuffer的内部格式。可选值：
		// gl.RGBA4: 4 red bits, 4 green bits, 4 blue bits 4 alpha bits.
		// gl.RGB565: 5 red bits, 6 green bits, 5 blue bits.
		// gl.RGB5_A1: 5 red bits, 5 green bits, 5 blue bits, 1 alpha bit.
		// gl.DEPTH_COMPONENT16: 16 depth bits.每个纹理单元包含16位。
		// gl.STENCIL_INDEX8: 8 stencil bits.
		// gl.DEPTH_STENCIL： 深度缓冲
	//width: Renderbuffer的像素宽度
	//height: Renderbuffer的像素高度

  var textureRtt=gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, textureRtt);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 512, 512, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
 
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureRtt, 0);
  //void gl.framebufferTexture2D(target, attachment, textarget, texture, level);  绑定texture到Framebuffer
  	//target：指定绑定目标。可选值gl.FRAMEBUFFER：表示用于渲染图像的颜色，alpha，depth和stencil缓存的数据集合。
	//attachment：指定texture的附着点。可选值：
		//gl.COLOR_ATTACHMENT0: 附加纹理到 framebuffer's color 缓存.
		// gl.DEPTH_ATTACHMENT: 附加纹理到 framebuffer's depth buffer.
		// gl.STENCIL_ATTACHMENT: 附加纹理到 framebuffer's stencil buffer.
	//textarget：指定纹理目标。
		// gl.TEXTURE_2D: A 2D image.
		// gl.TEXTURE_CUBE_MAP_POSITIVE_X: Image for the positive X face of the cube.
		// gl.TEXTURE_CUBE_MAP_NEGATIVE_X: Image for the negative X face of the cube.
		// gl.TEXTURE_CUBE_MAP_POSITIVE_Y: Image for the positive Y face of the cube.
		// gl.TEXTURE_CUBE_MAP_NEGATIVE_Y: Image for the negative Y face of the cube.
		// gl.TEXTURE_CUBE_MAP_POSITIVE_Z: Image for the positive Z face of the cube.
		// gl.TEXTURE_CUBE_MAP_NEGATIVE_Z: Image for the negative Z face of the cube.
	//texture: 要绑定的WebGLTexture对象。
	// level：指定 纹理图像的mipmap 等级。必须为0.
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, rb);
  //void gl.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer); 绑定WebGLRenderbuffer到 WebGLFramebuffer对象。
  	//target:指定framebuffer的绑定点。可选值：gl.FRAMEBUFFER
	//attachment：指定render buffer的附着点。可选值：
		//gl.COLOR_ATTACHMENT0: color buffer.
		// gl.DEPTH_ATTACHMENT: depth buffer.
		// gl.STENCIL_ATTACHMENT: stencil buffer.
	//renderbuffertarget：指定render buffer的绑定点。gl.RENDERBUFFER:单个图像的缓存数据存储以可渲染的内部各式.
	//renderbuffer：要绑定的renderbuffer对象。

//释放gl上下文
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	const triangleVertex =
	[
		-1,-1,-1,     0,0,        //uv坐标
		1,-1,-1,     1,0,
		1, 1,-1,     1,1,
		-1, 1,-1,     0,1,

		-1,-1, 1,     0,0,
		1,-1, 1,     1,0,
		1, 1, 1,     1,1,
		-1, 1, 1,     0,1,

		-1,-1,-1,     0,0,
		-1, 1,-1,     1,0,
		-1, 1, 1,     1,1,
		-1,-1, 1,     0,1,

		1,-1,-1,     0,0,
		1, 1,-1,     1,0,
		1, 1, 1,     1,1,
		1,-1, 1,     0,1,

		-1,-1,-1,     0,0,
		-1,-1, 1,     1,0,
		1,-1, 1,     1,1,
		1,-1,-1,     0,1,

		-1, 1,-1,     0,0,
		-1, 1, 1,     1,0,
		1, 1, 1,     1,1,
		1, 1,-1,     0,1
  ];

	const pointBuffer = gl.createBuffer();  
	gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer); 
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleVertex), gl.STATIC_DRAW); 

	//顶点渲染顺序，这里指定顺序
	const triangleFaces = 
	[
		0,1,2,
		0,2,3,

		4,5,6,
		4,6,7,

		8,9,10,
		8,10,11,

		12,13,14,
		12,14,15,

		16,17,18,
		16,18,19,

		20,21,22,
		20,22,23
  ];
	const faceBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer); 
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(triangleFaces), gl.STATIC_DRAW);

 	const projMatrix = LIBS.get_projection(40, canvas.width/canvas.height, 1, 100);
	  	const projMatrixRtt= LIBS.get_projection(40, 1, 1, 100);
 	const moveMatrix = LIBS.get_I4();  
	 const viewMatrix = LIBS.get_I4();
	const moveMatrixAuto = LIBS.get_I4();
	
		

		let theta = 0;
		let phi = 0; 


	//渲染
	

	gl.enable(gl.DEPTH_TEST);  
	gl.depthFunc(gl.LEQUAL);  
	gl.clearDepth(1.0);  

	let oldTime = 0;

	function animate (time) {
		//运动
		let dAngle=(time-oldTime);
		  if (!drag) {
			dX*=AMORTIZATION;
			dY*=AMORTIZATION;
			theta+=dX;
			phi+=dY;
		}

  //===== 向纹理上绘图 =====
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
	gl.clearColor(0, 0, 1, 1);
    gl.viewport(0.0, 0.0, 512, 512);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    LIBS.rotateY(moveMatrixAuto, dAngle*0.001);
    LIBS.rotateX(moveMatrixAuto, dAngle*0.002);
    LIBS.rotateZ(moveMatrixAuto, dAngle*0.003);

    //draw the rotating cube
    gl.uniformMatrix4fv(Pmatrix, false, projMatrixRtt);
    gl.uniformMatrix4fv(Vmatrix, false, viewMatrix);
    gl.uniformMatrix4fv(Mmatrix, false, moveMatrixAuto);

    if (cubeTexture.webglTexture) {
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, cubeTexture.webglTexture);
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.vertexAttribPointer(position, 3, gl.FLOAT, false,4*(3+2),0) ;
    gl.vertexAttribPointer(uv, 2, gl.FLOAT, false,4*(3+2),3*4) ;

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer);
    gl.drawElements(gl.TRIANGLES, 6*2*3, gl.UNSIGNED_SHORT, 0);

    gl.flush();
    gl.bindTexture(gl.TEXTURE_2D, null);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	//绘制end


gl.clearColor(0, 0, 0, 0);

		LIBS.set_I4(moveMatrix);
		LIBS.scaleX(moveMatrix, 0.5);
		LIBS.scaleY(moveMatrix, 0.5);
		LIBS.scaleZ(moveMatrix, 0.5);
		// LIBS.rotateY(moveMatrix, theta);
		// LIBS.rotateX(moveMatrix, phi); 
		LIBS.set_I4(viewMatrix);
		LIBS.translateZ(viewMatrix, -5); 
 
		 LIBS.rotateY(viewMatrix, -theta);
		 LIBS.rotateX(viewMatrix, -phi); 

		oldTime=time;
		
		gl.viewport(0, 0, canvas.width, canvas.height); 
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 
		gl.uniformMatrix4fv(Pmatrix, false, projMatrix); 
		gl.uniformMatrix4fv(Mmatrix, false, moveMatrix);
		gl.uniformMatrix4fv(Vmatrix, false, viewMatrix);

		    gl.bindTexture(gl.TEXTURE_2D, textureRtt); //绑定动态纹理


		//draw
		gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
		gl.vertexAttribPointer(position, 3, gl.FLOAT, gl.FALSE, 4*(3+2), 0); 
		gl.vertexAttribPointer(uv, 2, gl.FLOAT, gl.FALSE, 4*(3+2), 3*4 );  

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer);
		gl.drawElements(gl.TRIANGLES, 3*2*6, gl.UNSIGNED_SHORT, 0);  

		gl.flush();  


		requestAnimationFrame(animate);  
	}

	animate(0);
</script>
</body>
</html>