<!DOCTYPE html>
<html >
<head>
<title>example</title>
</head>
<body style="margin: 10px">
<canvas width="1024px" height="600px" id="canvas"></canvas>

<script src="./matrixLibs.js"></script>
<script type="text/javascript">
	const canvas = document.getElementById("canvas");
	const gl = canvas.getContext("webgl",  {antialias: true});	

	const vertexShader = `
		attribute vec3 position; //the position of the point
		attribute vec3 color; //点的颜色（R,G,B）
		uniform mat4 Pmatrix; //uniform变量的值在渲染中不变
		uniform mat4 Mmatrix; //模型变换矩阵：平移+旋转+缩放
		uniform mat4 Vmatrix; //视图变换矩阵：平移+旋转

		varying vec3 vColor; //用于将颜色传递到片元着色器

		void main(void) { //pre-built function
			gl_Position = Pmatrix * Vmatrix * Mmatrix * vec4(position, 1.0);  //矩阵运算在GPU中比在CPU中快得多。
			vColor = color; //vColor是顶点之间的差值
		}
	`;
	const fragmentShader = `
		precision mediump float; 

		varying vec3 vColor; //对应顶点着色器的vColor

		void main(void) {
			gl_FragColor = vec4(vColor, 1.);  //black
		}	
	`;

	const compileShader = function (source, type) {
		const shader = gl.createShader(type);
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			alert("ERROR IN "+ type + " SHADER : " + gl.getShaderInfoLog(shader));
			return false;
		}
		return shader;
	}

	let vShader = compileShader(vertexShader, gl.VERTEX_SHADER);
	let fShader = compileShader(fragmentShader, gl.FRAGMENT_SHADER);

	const shaderProgram = gl.createProgram();  
	gl.attachShader(shaderProgram, vShader);
	gl.attachShader(shaderProgram, fShader);
	
	gl.linkProgram(shaderProgram); 

	const Pmatrix = gl.getUniformLocation(shaderProgram, 'Pmatrix'); 
	const Mmatrix = gl.getUniformLocation(shaderProgram, 'Mmatrix');
	const Vmatrix = gl.getUniformLocation(shaderProgram, 'Vmatrix');

	let color = gl.getAttribLocation(shaderProgram, 'color');
	let position = gl.getAttribLocation(shaderProgram, 'position');
	gl.enableVertexAttribArray(color);
	gl.enableVertexAttribArray(position);  

	gl.useProgram(shaderProgram);  

	//顶点坐标数组, 这里的顺序不重要
	const triangleVertex =
	//  [   
	// 	-1, -1, -1,       0, 0, 0,     //下左后 
	// 	1, -1, -1,        1, 0, 0,     //下右后
	// 	1, 1, -1,          1, 1, 0,    //上右后
	// 	-1, 1, -1,          0, 1, 0,   //上左后
	// 	-1, -1, 1,          0, 0, 1,   //下左前
	// 	1, -1, 1,          1, 0, 1,    //下右前
	// 	1, 1, 1,          1, 1, 1,     //上右前
	// 	-1, 1, 1,          0, 1, 1    //上左前
	// ];
	[
    -1,-1,-1,     1,1,0,
    1,-1,-1,     1,1,0,
    1, 1,-1,     1,1,0,
    -1, 1,-1,     1,1,0,

    -1,-1, 1,     0,0,1,
    1,-1, 1,     0,0,1,
    1, 1, 1,     0,0,1,
    -1, 1, 1,     0,0,1,

    -1,-1,-1,     0,1,1,
    -1, 1,-1,     0,1,1,
    -1, 1, 1,     0,1,1,
    -1,-1, 1,     0,1,1,

    1,-1,-1,     1,0,0,
    1, 1,-1,     1,0,0,
    1, 1, 1,     1,0,0,
    1,-1, 1,     1,0,0,

    -1,-1,-1,     1,0,1,
    -1,-1, 1,     1,0,1,
    1,-1, 1,     1,0,1,
    1,-1,-1,     1,0,1,

    -1, 1,-1,     0,1,0,
    -1, 1, 1,     0,1,0,
    1, 1, 1,     0,1,0,
    1, 1,-1,     0,1,0

  ];

	const pointBuffer = gl.createBuffer();  
	gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer); 
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleVertex), gl.STATIC_DRAW); 

	//顶点渲染顺序，这里指定顺序
	const triangleFaces = 
	// [
	// 		0, 1, 2,
	// 		0, 2, 3,

	// 		4,5,6,
	// 		4,6,7,

	// 		0,3,7,
	// 		0,4,7,

	// 		1,2,6,
	// 		1,5,6,

	// 		2,3,6,
	// 		3,7,6,

	// 		0,1,5,
	// 		0,4,5
	// 	];
	[
    0,1,2,
    0,2,3,

    4,5,6,
    4,6,7,

    8,9,10,
    8,10,11,

    12,13,14,
    12,14,15,

    16,17,18,
    16,18,19,

    20,21,22,
    20,22,23

  ];
	const faceBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer); 
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(triangleFaces), gl.STATIC_DRAW);

 	const projMatrix = LIBS.get_projection(40, canvas.width/canvas.height, 1, 100);
 	const moveMatrix = LIBS.get_I4();  
	 const viewMatrix = LIBS.get_I4();
	LIBS.translateZ(viewMatrix, -5);  //
		LIBS.scaleX(moveMatrix, 0.5);
		LIBS.scaleY(moveMatrix, 0.5);
		LIBS.scaleZ(moveMatrix, 0.5);



	//渲染
	gl.clearColor(0, 0, 0, 0);

	gl.enable(gl.DEPTH_TEST);  
	gl.depthFunc(gl.LEQUAL);  
	gl.clearDepth(1.0);  

	let oldTime = 0;
	const animate = function (time) {
		//运动
		var dAngle=0.005*(time-oldTime);
		LIBS.rotateX(moveMatrix, dAngle*0.1);
		LIBS.rotateY(moveMatrix, dAngle*0.2);
		LIBS.rotateZ(moveMatrix, dAngle*0.3);

		oldTime=time;
		
		gl.viewport(0, 0, canvas.width, canvas.height); 
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 
		gl.uniformMatrix4fv(Pmatrix, false, projMatrix); 
		gl.uniformMatrix4fv(Mmatrix, false, moveMatrix);
		gl.uniformMatrix4fv(Vmatrix, false, viewMatrix);

		//draw
		gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
		gl.vertexAttribPointer(position, 3, gl.FLOAT, gl.FALSE, 4*(3+3), 0); 
		gl.vertexAttribPointer(color, 3, gl.FLOAT, gl.FALSE, 4*(3+3), 3*4 );  

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer);
		gl.drawElements(gl.TRIANGLES, 3*2*6, gl.UNSIGNED_SHORT, 0);  

		gl.flush();  


		requestAnimationFrame(animate);  
	}

	animate(0);
</script>
</body>
</html>