<!DOCTYPE html>
<html >
<head>
<title>example</title>
</head>
<body style="margin: 10px">
<canvas width="1024px" height="600px" id="canvas"></canvas>

<script src="./matrixLibs.js"></script>
<script type="text/javascript">
	const canvas = document.getElementById("canvas");
	const gl = canvas.getContext("webgl",  {antialias: true});	

	const vertexShader = `
		attribute vec3 position; //the position of the point
		attribute vec3 color; //点的颜色（R,G,B）
		uniform mat4 Pmatrix; //uniform变量的值在渲染中不变
		uniform mat4 Mmatrix; //模型变换矩阵：平移+旋转+缩放
		uniform mat4 Vmatrix; //视图变换矩阵：平移+旋转

		varying vec3 vColor; //用于将颜色传递到片元着色器

		void main(void) { //pre-built function
			gl_Position = Pmatrix * Vmatrix * Mmatrix * vec4(position, 1.0);  //矩阵运算在GPU中比在CPU中快得多。
			vColor = color; //vColor是顶点之间的差值
		}
	`;
	const fragmentShader = `
		precision mediump float; 

		varying vec3 vColor; //对应顶点着色器的vColor

		void main(void) {
			gl_FragColor = vec4(vColor, 1.);  //black
		}	
	`;

	const compileShader = function (source, type) {
		const shader = gl.createShader(type);
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			alert("ERROR IN "+ type + " SHADER : " + gl.getShaderInfoLog(shader));
			return false;
		}
		return shader;
	}

	let vShader = compileShader(vertexShader, gl.VERTEX_SHADER);
	let fShader = compileShader(fragmentShader, gl.FRAGMENT_SHADER);

	const shaderProgram = gl.createProgram();  
	gl.attachShader(shaderProgram, vShader);
	gl.attachShader(shaderProgram, fShader);
	
	gl.linkProgram(shaderProgram); 

	const Pmatrix = gl.getUniformLocation(shaderProgram, 'Pmatrix');
	const Mmatrix = gl.getUniformLocation(shaderProgram, 'Mmatrix');
	const Vmatrix = gl.getUniformLocation(shaderProgram, 'Vmatrix');

	let color = gl.getAttribLocation(shaderProgram, 'color');
	let position = gl.getAttribLocation(shaderProgram, 'position');
	gl.enableVertexAttribArray(color);
	gl.enableVertexAttribArray(position);  

	gl.useProgram(shaderProgram);  

	//顶点坐标数组
	const triangleVertex = [   
		-1, -1, 0,            
		0, 0, 1,   
		1, -1 , 0,
		1, 1, 0, 
		1, 1, 0,
		1, 0, 0,
		-1, 1, 0,            
		0, 1, 0
	];

	const pointBuffer = gl.createBuffer();  
	gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer); 
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleVertex), gl.STATIC_DRAW); 

	//顶点渲染顺序
	const triangleFaces = [0, 1, 2, 0, 2, 3 ];
	const faceBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer); 
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(triangleFaces), gl.STATIC_DRAW);


	const projMatrix = LIBS.get_projection(40, canvas.width/canvas.height, 1, 100);
	const moveMatrix = LIBS.get_I4();  
	const viewMatrix = LIBS.get_I4();
	LIBS.translateZ(viewMatrix, -5);  

	//渲染
	gl.clearColor(0, 0, 0, 0);
	gl.enable(gl.DEPTH_TEST); 
	gl.depthFunc(gl.LEQUAL); 
	gl.clearDepth(1.0); 

	let oldTime = 0;
	const animate = function (time) {
		//运动
		var dAngle=0.0005*(time-oldTime);
		LIBS.rotateX(moveMatrix, dAngle);
		oldTime=time;
		
		gl.viewport(0, 0, canvas.width, canvas.height); 
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 
		gl.uniformMatrix4fv(Pmatrix, false, projMatrix); 
		gl.uniformMatrix4fv(Mmatrix, false, moveMatrix);
		gl.uniformMatrix4fv(Vmatrix, false, viewMatrix);

		//draw
		gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
		gl.vertexAttribPointer(position,3 , gl.FLOAT, gl.FALSE, 4*(3+3), 0); 
		gl.vertexAttribPointer(color, 3, gl.FLOAT, gl.FALSE, 4*(3+3), 3*4 );  
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer);
		gl.drawElements(gl.TRIANGLE_STRIP, 6, gl.UNSIGNED_SHORT, 0);  
		gl.flush();  

		requestAnimationFrame(animate);  //requestAnimationFrame为函数传递一个时间戳作为参数
	}

	animate(0);
</script>
</body>
</html>