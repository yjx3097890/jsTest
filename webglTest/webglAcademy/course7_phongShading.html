<!DOCTYPE html>
<html >
<head>
<title>example</title>
</head>
<body style="margin: 10px">
<canvas width="1024px" height="600px" id="canvas"></canvas>

<script src="./matrixLibs.js"></script>
<script type="text/javascript">
	const canvas = document.getElementById("canvas");
	const gl = canvas.getContext("webgl",  {antialias: true});	
	const ext = gl.getExtension('OES_element_index_uint') || gl.getExtension("MOZ_OES_element_index_uint") ||
        gl.getExtension("WEBKIT_OES_element_index_uint");  //获得GL_OES_element_index_uint扩展。

  let AMORTIZATION=0.9;  
	let drag = false;
	let oldPosition=[0, 0];

	const mouseDown = function (event) {
		event.preventDefault();
		drag = true;
		oldPosition[0] = event.clientX;
		oldPosition[1] = event.clientY;
	};
	const mouseUp = function () {
		drag = false;
	}
	let dX=0, dY=0;
	const mouseMove = function (event) {
		if (!drag) return false;
		event.preventDefault();

		dX=(event.clientX-oldPosition[0])/canvas.width * 2*Math.PI ;
		dY=(event.clientY-oldPosition[1])/canvas.height * 2*Math.PI ;
	 theta+=dX;
	 phi+=dY;
		oldPosition[0]=event.clientX, oldPosition[1]=event.clientY;
	}
	canvas.addEventListener("mousedown", mouseDown, false);
	canvas.addEventListener("mouseup", mouseUp, false);
	canvas.addEventListener("mouseout", mouseUp, false);
	canvas.addEventListener("mousemove", mouseMove, false);

	const vertexShader = `
		attribute vec3 position; //the position of the point
		attribute vec2 uv;
		attribute vec3 normal; //法线向量

		uniform mat4 Pmatrix; 
		uniform mat4 Mmatrix; 
		uniform mat4 Vmatrix; 


		varying vec2 vuv; 
		varying vec3 vNormal; 
		varying vec3 vView;

		void main(void) { //pre-built function
			gl_Position = Pmatrix * Vmatrix * Mmatrix * vec4(position, 1.0);  //矩阵运算在GPU中比在CPU中快得多。
			vNormal = vec3(Mmatrix*vec4(normal, 0.0));  //将法线向量放到场景中
			vView=vec3(Vmatrix*Mmatrix*vec4(position,1.0)); //从camera指向位置点
			vuv = uv;
		}
	`;
	const fragmentShader = `
		precision mediump float; 

		uniform sampler2D sampler;
		varying vec2 vuv;
		varying vec3 vNormal;
		varying vec3 vView;

		//fragment 中是设备标准化坐标系，左手系？有问题
		const vec3 source_ambient_color=vec3(1.,1.,1.);  //环境光颜色
		const vec3 source_diffuse_color=vec3(1.,2.,4.); //漫反射光颜色
		const vec3 source_specular_color=vec3(1., 1., 1.);  //镜面反射光颜色
		const vec3 source_direction=vec3(0., 0., 1.);   //入射方向， 被照射点指向光源

		const vec3 mat_ambient_color=vec3(0.3,0.3,0.3);  //环境反射材质属性
		const vec3 mat_diffuse_color=vec3(.5,.5,.5);   //漫反射材质属性
		const vec3 mat_specular_color=vec3(1.,1.,1.);   //镜面反射材质属性
		const float mat_shininess=10.;  //反射率

		void main(void) {
			vec3 color = vec3(texture2D(sampler, vuv));
			vec3 IAmbient = source_ambient_color * mat_ambient_color;
			vec3 IDiffuse = source_diffuse_color * mat_diffuse_color * max(0.0, dot(vNormal, source_direction)); //vNormal和source_direction必须为单位向量
			vec3 V = normalize(vView);  //观察方向
			vec3 R = reflect(source_direction, vNormal); //计算光反射后方向，reflect为内置函数
			vec3 ISpecular=source_specular_color * mat_specular_color * pow(max(dot(R,V),0.), mat_shininess);  //镜面反射公式
			vec3 I =  IAmbient + IDiffuse + ISpecular;
			gl_FragColor = vec4(I*color, 1.0); 
		}	
	`;

	const compileShader = function (source, type) {
		const shader = gl.createShader(type);
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			alert("ERROR IN "+ type + " SHADER : " + gl.getShaderInfoLog(shader));
			return false;
		}
		return shader;
	}

	let vShader = compileShader(vertexShader, gl.VERTEX_SHADER);
	let fShader = compileShader(fragmentShader, gl.FRAGMENT_SHADER);

	const shaderProgram = gl.createProgram();  
	gl.attachShader(shaderProgram, vShader);
	gl.attachShader(shaderProgram, fShader);
	
	gl.linkProgram(shaderProgram); 

	const Pmatrix = gl.getUniformLocation(shaderProgram, 'Pmatrix'); 
	const Mmatrix = gl.getUniformLocation(shaderProgram, 'Mmatrix');
	const Vmatrix = gl.getUniformLocation(shaderProgram, 'Vmatrix');
	const sampler = gl.getUniformLocation(shaderProgram, 'sampler');
	//sampler为着色器提供纹理对象.
	//一个shader可以同时使用多个纹理，通过多个sampler.
	//sample的最大个数根据显卡而定，通常为16，但是低配置的可能只有4.
	
	let uv = gl.getAttribLocation(shaderProgram, 'uv');
	let position = gl.getAttribLocation(shaderProgram, 'position');
	let normal = gl.getAttribLocation(shaderProgram, 'normal');
	gl.enableVertexAttribArray(uv);
	gl.enableVertexAttribArray(position);  
	gl.enableVertexAttribArray(normal);

	gl.useProgram(shaderProgram);  

 const getTexture=function(image_URL){
    const image=new Image();
    image.src=image_URL;
    image.webglTexture=false;
    image.onload=function(e) {
      const texture=gl.createTexture();              // 新建纹理对象
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);   
      gl.bindTexture(gl.TEXTURE_2D, texture);        

	  //常用的纹理格式有：GL_RGB, GL_RGBA, GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA。
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);  
	 //设置纹理映射参数
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR); //当所要显示的纹理比加载进来的纹理大时，采用GL_LINEAR的方法来放大处理
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
	 gl.generateMipmap(gl.TEXTURE_2D);  //创建一组连续变小的纹理，在场景缩放时选择最合适的使用。消除闪烁，并减少计算
      gl.bindTexture(gl.TEXTURE_2D, null); //释放上下文

      image.webglTexture=texture;
    };

    return image;
  };
  //纹理对象
	gl.uniform1i(sampler, 0);
   const cubeTexture=getTexture("./dragon.png");
	
   let cubeVertex=false, cubeFaces=false, cubePoints=0;
   LIBS.get_json('./dragon.json', function (dragon) {
	   //vertices
	   cubeVertex=gl.createBuffer();
	   gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertex);
	   gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(dragon.vertices), gl.STATIC_DRAW);

	   //faces
	   cubeFaces=gl.createBuffer();
	   gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeFaces);
	   gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(dragon.indices), gl.STATIC_DRAW);

	   cubePoints = dragon.indices.length;

	   animate(0);
   });
 
	 
 	const projMatrix = LIBS.get_projection(60, canvas.width/canvas.height, 1, 100);
 	const moveMatrix = LIBS.get_I4();  
	 const viewMatrix = LIBS.get_I4();
	
		

		let theta = 0;
		let phi = 0; 


	//渲染
	gl.clearColor(0, 0, 0, 0);

	gl.enable(gl.DEPTH_TEST);  
	gl.depthFunc(gl.LEQUAL);  
	gl.clearDepth(1.0);  

	let oldTime = 0;

	const animate = function (time) {
		//运动
		let dAngle=(time-oldTime);
		  if (!drag) {
			dX*=AMORTIZATION;
			dY*=AMORTIZATION;
			theta+=dX;
			phi+=dY;
		}
		LIBS.set_I4(moveMatrix);
		// LIBS.scaleX(moveMatrix, 0.5);
		// LIBS.scaleY(moveMatrix, 0.5);
		// LIBS.scaleZ(moveMatrix, 0.5);
		 LIBS.rotateY(moveMatrix, theta);
		 LIBS.rotateX(moveMatrix, phi); 
		LIBS.set_I4(viewMatrix);
		LIBS.translateZ(viewMatrix, -20);
		LIBS.translateY(viewMatrix, -4) 
 
		//  LIBS.rotateY(viewMatrix, -theta);
		//  LIBS.rotateX(viewMatrix, -phi); 

		oldTime=time;
		
		gl.viewport(0, 0, canvas.width, canvas.height); 
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 
		gl.uniformMatrix4fv(Pmatrix, false, projMatrix); 
		gl.uniformMatrix4fv(Mmatrix, false, moveMatrix);
		gl.uniformMatrix4fv(Vmatrix, false, viewMatrix);

		if (cubeTexture.webglTexture) {
 			gl.activeTexture(gl.TEXTURE0);  //选择活动纹理单元,确定了后续的纹理状态改变影响哪个纹理
			 //void activeTexture(	GLenum texture);
				// texture: 指定哪一个纹理单元被置为活动状态。texture必须是GL_TEXTUREi之一，其中0 <= i < GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS，初始值为GL_TEXTURE0

    	    gl.bindTexture(gl.TEXTURE_2D, cubeTexture.webglTexture);
		}

		//draw
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertex);
		gl.vertexAttribPointer(position, 3, gl.FLOAT, gl.FALSE, 4*(3+3+2), 0); 
		gl.vertexAttribPointer(normal, 3, gl.FLOAT, gl.FALSE, 4*(3+3+2), 3*4);  //顶点坐标格式为：X,Y,Z,Nx,Ny,Nz,U,V
		gl.vertexAttribPointer(uv, 2, gl.FLOAT, gl.FALSE, 4*(3+3+2), (3+3)*4 );  

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeFaces);
		gl.drawElements(gl.TRIANGLES, cubePoints, gl.UNSIGNED_INT, 0);   //webgl中，2字节的short型index，最多只能标记2^16 = 65536个坐标。不够用，这里只能用4字节的int。

		gl.flush();  


		requestAnimationFrame(animate);  
	}


</script>
</body>
</html>