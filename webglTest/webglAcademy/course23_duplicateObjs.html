<!DOCTYPE html>
<html >
<head>
<title>example</title>
</head>
<body style="margin: 10px">
<canvas width="1024px" height="600px" id="canvas"></canvas>

<script src="./matrixLibs.js"></script>
<script type="text/javascript">
	const canvas = document.getElementById("canvas");
	const gl = canvas.getContext("webgl",  {antialias: true});	

  let AMORTIZATION=0.9;  
	let drag = false;
	let oldPosition=[0, 0];

	const mouseDown = function (event) {
		event.preventDefault();
		drag = true;
		oldPosition[0] = event.clientX;
		oldPosition[1] = event.clientY;
	};
	const mouseUp = function () {
		drag = false;
	}
	let dX=0, dY=0;
	const mouseMove = function (event) {
		if (!drag) return false;
		event.preventDefault();

		dX=(event.clientX-oldPosition[0])/canvas.width * 2*Math.PI ;
		dY=(event.clientY-oldPosition[1])/canvas.height * 2*Math.PI ;
	 theta+=dX;
	 phi+=dY;
		oldPosition[0]=event.clientX, oldPosition[1]=event.clientY;
	}
	canvas.addEventListener("mousedown", mouseDown, false);
	canvas.addEventListener("mouseup", mouseUp, false);
	canvas.addEventListener("mouseout", mouseUp, false);
	canvas.addEventListener("mousemove", mouseMove, false);

	const vertexShader = `
		attribute vec3 position; //the position of the point
		attribute vec3 color; //点的颜色（R,G,B）
		uniform mat4 Pmatrix; //uniform变量的值在渲染中不变
		uniform mat4 Mmatrix; //模型变换矩阵：平移+旋转+缩放
		uniform mat4 Vmatrix; //视图变换矩阵：平移+旋转

		varying vec3 vColor; //用于将颜色传递到片元着色器

		void main(void) { //pre-built function
			gl_Position = Pmatrix * Vmatrix * Mmatrix * vec4(position, 1.0);  //矩阵运算在GPU中比在CPU中快得多。
			vColor = color; //vColor是顶点之间的差值
		}
	`;
	const fragmentShader = `
		precision mediump float; 

		varying vec3 vColor; //对应顶点着色器的vColor
		uniform float greyscality;

		void main(void) {
			float greyscaleValue=(vColor.r+vColor.g+vColor.b) / 3.0;
			vec3 greyColor = vec3(greyscaleValue);

			vec3 color = mix(greyColor, vColor, greyscality);  //float mix (float x, float  y, float  a ) ,Returns  x * (1.0 –  a ) +  y* a,
			gl_FragColor = vec4(color, 1.);  //black
		}	
	`;

	const compileShader = function (source, type) {
		const shader = gl.createShader(type);
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			console.log("ERROR IN "+ type + " SHADER : " + gl.getShaderInfoLog(shader));
			return false;
		}
		return shader;
	}

	let vShader = compileShader(vertexShader, gl.VERTEX_SHADER);
	let fShader = compileShader(fragmentShader, gl.FRAGMENT_SHADER);

	const shaderProgram = gl.createProgram();  
	gl.attachShader(shaderProgram, vShader);
	gl.attachShader(shaderProgram, fShader);
	
	gl.linkProgram(shaderProgram); 

	const Pmatrix = gl.getUniformLocation(shaderProgram, 'Pmatrix'); 
	const Mmatrix = gl.getUniformLocation(shaderProgram, 'Mmatrix');
	const Vmatrix = gl.getUniformLocation(shaderProgram, 'Vmatrix');
	const greyscality = gl.getUniformLocation(shaderProgram, 'greyscality');


	let color = gl.getAttribLocation(shaderProgram, 'color');
	let position = gl.getAttribLocation(shaderProgram, 'position');
	gl.enableVertexAttribArray(color);
	gl.enableVertexAttribArray(position);  

	gl.useProgram(shaderProgram);  

	//顶点坐标数组, 这里的顺序不重要
	const triangleVertex =
	[
		-1,-1,-1,     1,1,0,
		1,-1,-1,     1,1,0,
		1, 1,-1,     1,1,0,
		-1, 1,-1,     1,1,0,

		-1,-1, 1,     0,0,1,
		1,-1, 1,     0,0,1,
		1, 1, 1,     0,0,1,
		-1, 1, 1,     0,0,1,

		-1,-1,-1,     0,1,1,
		-1, 1,-1,     0,1,1,
		-1, 1, 1,     0,1,1,
		-1,-1, 1,     0,1,1,

		1,-1,-1,     1,0,0,
		1, 1,-1,     1,0,0,
		1, 1, 1,     1,0,0,
		1,-1, 1,     1,0,0,

		-1,-1,-1,     1,0,1,
		-1,-1, 1,     1,0,1,
		1,-1, 1,     1,0,1,
		1,-1,-1,     1,0,1,

		-1, 1,-1,     0,1,0,
		-1, 1, 1,     0,1,0,
		1, 1, 1,     0,1,0,
		1, 1,-1,     0,1,0
  ];

	const pointBuffer = gl.createBuffer();  
	gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer); 
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(triangleVertex), gl.STATIC_DRAW); 

	//顶点渲染顺序，这里指定顺序
	const triangleFaces = 
	[
		0,1,2,
		0,2,3,

		4,5,6,
		4,6,7,

		8,9,10,
		8,10,11,

		12,13,14,
		12,14,15,

		16,17,18,
		16,18,19,

		20,21,22,
		20,22,23
  ];
	const faceBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer); 
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(triangleFaces), gl.STATIC_DRAW);

	/*========================= THE TETRAHEDRON 四面体 ========================= */
  //POINTS :
  var tetrahedron_vertex=[
    //底部的点， included in the plane y=-1
    -1,-1,-1,     1,0,0,
    1,-1,-1,     0,1,0,
    0,-1,1,      0,0,1,

    //顶点:, in white
    0,1,0,     1,1,1
  ];

  var tetrahedronVertex = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, tetrahedronVertex);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tetrahedron_vertex),
    gl.STATIC_DRAW);

  //TETRAHEDRON FACES :
  var tetrahedron_faces = [
    0,1,2, //base

    0,1,3, //side 0
    1,2,3, //side 1
    0,2,3  //side 2
  ];
  var tetrahedronFaces= gl.createBuffer ();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tetrahedronFaces);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(tetrahedron_faces),
    gl.STATIC_DRAW);


 	const projMatrix = LIBS.get_projection(40, canvas.width/canvas.height, 1, 100);
 	const moveMatrix = LIBS.get_I4();  
	 const moveMatrix2 = LIBS.get_I4();
	const moveMatrix3 = LIBS.get_I4();
	 const viewMatrix = LIBS.get_I4();

	 	LIBS.scaleX(moveMatrix3, 0.5);
		LIBS.scaleY(moveMatrix3, 0.5);
		LIBS.scaleZ(moveMatrix3, 0.5); 
		

		let theta = 0;
		let phi = 0; 


	//渲染
	gl.clearColor(0, 0, 0, 0);

	gl.enable(gl.DEPTH_TEST);  
	gl.depthFunc(gl.LEQUAL);  
	gl.clearDepth(1.0);  

	let oldTime = 0;
	const animate = function (time) {
		//运动
		let dAngle=(time-oldTime);
		  if (!drag) {
			dX*=AMORTIZATION;
			dY*=AMORTIZATION;
			theta+=dX;
			phi+=dY;
		}

  LIBS.rotateX(moveMatrix3, dAngle*0.0031);
    LIBS.rotateZ(moveMatrix3, Math.cos(time)*dAngle*0.0022);
    LIBS.rotateY(moveMatrix3, dAngle*-0.0034);

		LIBS.set_I4(viewMatrix);
		LIBS.translateZ(viewMatrix, -5); 


		LIBS.set_I4(moveMatrix);
		LIBS.scaleX(moveMatrix, 0.5);
		LIBS.scaleY(moveMatrix, 0.5);
		LIBS.scaleZ(moveMatrix, 0.5); 

		LIBS.set_I4(moveMatrix2);
		LIBS.scaleX(moveMatrix2, 0.5);
		LIBS.scaleY(moveMatrix2, 0.5);
		LIBS.scaleZ(moveMatrix2, 0.5); 

		let radius=1; //half distance between the cube centers
		let pos_x=radius*Math.cos(phi)*Math.cos(theta);
		let pos_y=-radius*Math.sin(phi);
		let pos_z=-radius*Math.cos(phi)*Math.sin(theta);

     LIBS.set_position(moveMatrix, pos_x, pos_y, pos_z);
    LIBS.set_position(moveMatrix2, -pos_x, -pos_y, -pos_z);

	//先Z后Y
		  LIBS.rotateZ(moveMatrix, -phi); //正方体跟着位置转
		 LIBS.rotateZ(moveMatrix2, -phi); 

		  LIBS.rotateY(moveMatrix, theta); //正方体跟着位置转
		 LIBS.rotateY(moveMatrix2, theta); 
		

		oldTime=time;
		
		gl.viewport(0, 0, canvas.width, canvas.height); 
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); 
		gl.uniformMatrix4fv(Pmatrix, false, projMatrix); 
		gl.uniformMatrix4fv(Mmatrix, false, moveMatrix);
		gl.uniformMatrix4fv(Vmatrix, false, viewMatrix);
		gl.uniform1f(greyscality, 1);

		//draw
		gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
		gl.vertexAttribPointer(position, 3, gl.FLOAT, gl.FALSE, 4*(3+3), 0); 
		gl.vertexAttribPointer(color, 3, gl.FLOAT, gl.FALSE, 4*(3+3), 3*4 );  

		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer);
		gl.drawElements(gl.TRIANGLES, 3*2*6, gl.UNSIGNED_SHORT, 0);  

		//在webgl中，当对象（矩阵，buffer等）绑定到上下文中时，会一直保留直到别的元素被绑定。
		gl.uniform1f(greyscality, 0.3);
		gl.uniformMatrix4fv(Mmatrix, false, moveMatrix2);
		gl.drawElements(gl.TRIANGLES, 3*2*6, gl.UNSIGNED_SHORT, 0); 

		//draw四面体
		gl.uniform1f(greyscality, 1);
		gl.uniformMatrix4fv(Mmatrix, false, moveMatrix3); 
		gl.bindBuffer(gl.ARRAY_BUFFER, tetrahedronVertex);
        gl.vertexAttribPointer(position, 3, gl.FLOAT, false, 4*(3+3), 0) ;
        gl.vertexAttribPointer(color, 3, gl.FLOAT, false, 4*(3+3), 3*4) ;
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, tetrahedronFaces);

		gl.uniform1f(greyscality, 1);	
		gl.drawElements(gl.TRIANGLES, 3*2, gl.UNSIGNED_SHORT, 0);  
		gl.uniform1f(greyscality, 0);
		gl.drawElements(gl.TRIANGLES, 3*2, gl.UNSIGNED_SHORT, 6*2);  



		gl.flush();  


		requestAnimationFrame(animate);  
	}

	animate(0);
</script>
</body>
</html>