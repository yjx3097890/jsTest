<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>

		<script src="./threejs/three.js"></script>
				<script src="./threejs/loaders/ColladaLoader.js"></script>

		<script>

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth/ window.innerHeight, 0.1, 1000);
			camera.position.z = 20;
			camera.position.y = 3;
			camera.lookAt(new THREE.Vector3(0, 0, 0));

			var posX=0, posZ=20;
			  var speedX=0, speedZ=0; //camera speed
			window.onkeydown=function(event){
				keyUpDown(event.keyCode, 0.1);
			};
			window.onkeyup=function(event){
				keyUpDown(event.keyCode, 0);
			};
			var keyUpDown=function(keycode, sensibility) {
				switch(keycode) {
				case 37: //left arrow
					speedX=-1*sensibility;
					break;
				case 39: //right arrow
					speedX=1*sensibility;
					break;
				case 38: //up arrow
					speedZ=-1*sensibility;
					break;
				case 40: //down arrow
					speedZ=1*sensibility;
					break;
				} //end switch keycode
			};
			  var drag=false, oldX, oldY, dX=0, dY=0, rotX=0, rotY=0;
			window.onmousedown=function(event) {
				drag=true;
				oldX=event.clientX,
				oldY=event.clientY;
			};
			window.onmouseup=function() {
				drag=false;
			};
			window.onmousemove=function(event) {
				if (!drag) return false;

				dX=event.clientX-oldX,
				dY=event.clientY-oldY;

				oldX=event.clientX,
				oldY=event.clientY;
			};
			setInterval(function() {
				   var cos=Math.cos(rotY);
    var sin=Math.sin(rotY);

    posX+=speedX*cos+speedZ*sin;
    posZ+=speedX*-sin+speedZ*cos;
				camera.position.set(posX, 5, posZ);
				rotY-=dX*0.005,
				rotX-=dY*0.005;
				camera.rotation.set(0,0,0);
				
	// 			camera.rotateY(rotY);
    // camera.rotateX(rotX);

if (!drag) {
      dX*=0.9, dY*=0.9;
    }
				 
			}, 16);

			//光源
			let spotLight = new THREE.SpotLight(0xffffff);
			spotLight.intensity = 2;
			spotLight.position.set(0, 10, 5);
			spotLight.castShadow = true;
			spotLight.shadow.mapSize.width = 512;
			spotLight.shadow.mapSize.height = 512;
			spotLight.shadow.camera.near = 5;
			spotLight.shadow.camera.far = 20;
			spotLight.shadow.camera.fov = 60;
			scene.add(spotLight);
			let ambientLight = new THREE.AmbientLight(0xffaa33);
			ambientLight.intensity = 1;
			scene.add(ambientLight);
			let spotHelper = new THREE.CameraHelper( spotLight.shadow.camera );
			scene.add(spotHelper);

			 var spotLightX=0, spotLightZ=0, spotLightTheta=0;
			setInterval(function() {
				spotLightTheta+=0.1;
				spotLightX=5*Math.cos(spotLightTheta),
				spotLightZ=5*Math.sin(spotLightTheta),
				spotLight.position.set(spotLightX,10,spotLightZ);
			}, 16);
			
			//方形
			let  geometry = new THREE.BoxGeometry(1, 1, 1);
			let material = new THREE.MeshBasicMaterial({color: 0xff0000});
			let cube = new THREE.Mesh(geometry, material);
			scene.add(cube);

			//线
			let lineMaterial = new THREE.LineBasicMaterial({color: 0x00ff00, linewidth: 20});
			let vertices = new Float32Array([
				-2, 0, 0,
				0, 2, 0,
				2, 0, 0
			]);
			//调整buffer大小的操作十分昂贵，但可以更新其内容
			let lineGeometry = new THREE.BufferGeometry();
			lineGeometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
			const line = new THREE.Line(lineGeometry, lineMaterial);
			scene.add(line);

			//平面
			let planeGeometry = new THREE.PlaneGeometry(200, 200);
			const texLoader = new THREE.TextureLoader();
			let planeMaterial;
			let plane ;
			texLoader.load('funkyGround.jpg', function (texture){
				planeMaterial = new THREE.MeshPhongMaterial({
					color: 0xdddddd,
					specular: 0x009900,
					map: texture,
					shininess: 30
				});
				plane = new THREE.Mesh(planeGeometry, planeMaterial);
				planeMaterial.map.wrapS = THREE.RepeatWrapping;
				planeMaterial.map.wrapT = THREE.RepeatWrapping;
				planeMaterial.map.repeat.set( 200, 200 );
				plane.position.set(0, 0, 0);
				plane.rotation.x = -Math.PI / 2;
				plane.castShadow = false; //不用于计算阴影
  				plane.receiveShadow = true;  //接收阴影
				
				scene.add(plane);
			});
			
			//model 
			let tux;
			let loader = new THREE.ColladaLoader();
			loader.load( 'tux.dae', function ( collada ) {
				tux = collada.scene;

				tux.scale.x = tux.scale.y = tux.scale.z = 4;
				tux.position.set(0,1.5,0);
				tux.rotateX(Math.PI);
				tux.children[0].children[0].castShadow = true;
				tux.children[0].children[0].receiveShadow = true;

				scene.add(tux);
			});

			//渲染
            const renderer = new THREE.WebGLRenderer({
				antialias  : true
			});
            renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFShadowMap;
            document.body.appendChild(renderer.domElement);
			function animate() {
				requestAnimationFrame(animate);
				renderer.render(scene, camera);
				cube.rotation.x += 0.01;
				cube.rotation.y += 0.01;	
			}
			animate();
		</script>
	</body>
</html>