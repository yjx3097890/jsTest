<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - shaders [custom]</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}

		

		
		</style>
	</head>
	<body>

		<div id="container"></div>
		

		<script src="three.js"></script>

		<script id="fragment_shader" type="x-shader/x-fragment">

            #ifdef GL_ES
            precision mediump float;
            #endif

            uniform float time;
            uniform vec2 mouse;
            uniform vec2 resolution;
            
            varying vec2 vUv;
            //MrOMGWTF

            vec3 flare(vec2 spos, vec2 fpos, vec3 clr)
            {
                vec3 color;
                float d = distance(spos, fpos);
                vec2 dd = spos - fpos;
                dd = abs(dd);
                
                color = clr * max(0.0, 0.025 / dd.y) * max(0.0, 1.1 -  dd.x);
                color += clr * max(0.0, 0.05 / d);   //原始光源
                color += clr * max(0.0, 0.1 / distance(spos, -fpos)) * 0.15 ;    //第二个斑点
               color += clr * max(0.0, 0.13 - distance(spos, -fpos * 1.5)) * 1.5 ;     //第三个斑点
                color += clr * max(0.0, 0.07 - distance(spos, -fpos * 0.4)) * 2.0 ;     //第一个斑点
                
                return color;
            }

            float noise(vec2 pos)
            {
                return fract(1111. * sin(111. * dot(pos, vec2(2222., 22.))));	
            }

            void main( void ) {

                vec2 position = ( vUv * 2.0 ) - 1.0;
                position.x *= resolution.x / resolution.y;
                //float omega = time*2.;
                float omega = (sin(time));
                float divisor = 1.0-.5*cos(omega);
                vec3 color = flare(position, vec2(sin(omega)/2.0/divisor, cos(omega)/2.0/divisor) * 0.5 , vec3(1.5, 0.8, 1.5));
                
                

                gl_FragColor = vec4( color * (0.95 + noise(position*0.001 + 0.00001) * 0.05), 1.0 );

            }
        </script>
             
		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>

		<script>

		

			var container;

			var camera, scene, renderer;

			var uniforms, material, mesh;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var clock = new THREE.Clock();

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 40, windowHalfX / windowHalfY, 1, 3000 );
				camera.position.z = 4;

				scene = new THREE.Scene();

				start_time = Date.now();

				uniforms = {
					time: { type: "f", value: 1.0 },
					resolution: { type: "v2", value: new THREE.Vector2() }
				};

	

				var size = 2.5;


					material = new THREE.ShaderMaterial( {

						uniforms: uniforms,
						vertexShader: document.getElementById( "vertexShader" ).textContent,
						fragmentShader: document.getElementById( "fragment_shader" ).textContent

						} );

					

					mesh = new THREE.Mesh( new THREE.PlaneGeometry(  size * windowHalfX / windowHalfY, size ), material );
					mesh.position.x = 0.0;
					mesh.position.y =  0.0;
					scene.add( mesh );

					

				

				renderer = new THREE.WebGLRenderer();
				container.appendChild( renderer.domElement );


				onWindowResize();

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize( event ) {

				uniforms.resolution.value.x = window.innerWidth;
				uniforms.resolution.value.y = window.innerHeight;


				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				var delta = clock.getDelta();     //距离上次绘制经过的时间（秒）

			
				uniforms.time.value = clock.elapsedTime;    //clock第一次调用getDelta后经过的时间（秒）


				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
