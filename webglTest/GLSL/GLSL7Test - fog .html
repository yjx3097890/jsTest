<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - shaders [custom]</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}

		

		
		</style>
	</head>
	<body>

		<div id="container"></div>
		

		<script src="three.js"></script>
        <script type="text/javascript" src="TrackballControls.js"></script>
        
		<script id="fragment_shader" type="x-shader/x-fragment">

            #ifdef GL_ES
            precision mediump float;
            #endif

            uniform float time;
            uniform vec2 mouse;
            uniform vec2 resolution;
            
            varying vec2 vUv;
            //MrOMGWTF

            vec3 flare(vec2 spos, vec2 fpos, vec3 clr)
            {
                vec3 color;
                float d = distance(spos, fpos);
                vec2 dd;
                dd.x = spos.x - fpos.x;
                dd.y = spos.y - fpos.y;
                dd = abs(dd);
                
                color = clr * max(0.0, 0.025 / dd.y) * max(0.0, 1.1 -  dd.x);
                color += clr * max(0.0, 0.05 / d);
                color += clr * max(0.0, 0.1 / distance(spos, -fpos)) * 0.15 ;
                color += clr * max(0.0, 0.13 - distance(spos, -fpos * 1.5)) * 1.5 ;
                color += clr * max(0.0, 0.07 - distance(spos, -fpos * 0.4)) * 2.0 ;
                
                
                return color;
            }

            float noise(vec2 pos)
            {
                return fract(1111. * sin(111. * dot(pos, vec2(2222., 22.))));	
            }

            void main( void ) {

                vec2 position = ( vUv * 2.0 ) - 1.0;
                position.x *= resolution.x / resolution.y;
                float omega = time*2.;//-(sin(time)/1.5);
                float divisor = 1.0-0.5*cos(omega);
                vec3 color = flare(position, vec2(sin(omega)/2./divisor, cos(omega)/2./divisor) * 0.5 , vec3(0.5, 0.8, 1.5));
                
                

                gl_FragColor = vec4( color * (0.95 + noise(position*0.001 + 0.00001) * 0.05), 1.0 );

                float fogDensity = 0.55;
                vec3 fogColor = vec3(0.0, 0.0, 0.0); 
                   //fog
				float depth = gl_FragCoord.z / gl_FragCoord.w;
				float fogFactor = exp( - fogDensity * fogDensity * depth * depth );
				gl_FragColor = mix( vec4( fogColor, gl_FragColor.a ), gl_FragColor, fogFactor );
            }
        </script>
             
		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 vUv;

			void main()
			{
				vUv = uv;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>

		<script>

		

			var container;

			var camera, scene, renderer;

			var uniforms, material, mesh,controls;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var clock = new THREE.Clock();

			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 40, windowHalfX / windowHalfY, 1, 3000 );
				camera.position.z = 5;
                
                 controls = new THREE.TrackballControls( camera );
                
                 //旋转速度
                controls.rotateSpeed = 1.0;
                //变焦速度
                controls.zoomSpeed = 1.2;
                //平移速度
                controls.panSpeed = 0.8;
                //是否不变焦
                controls.noZoom = false;
                //是否不平移
                controls.noPan = true;
                //可能是惯性 true没有惯性
                controls.staticMoving = false;
                //动态阻尼系数 就是灵敏度
                controls.dynamicDampingFactor = 0.3;

				scene = new THREE.Scene();

      
                
				start_time = Date.now();

				uniforms = {
					time: { type: "f", value: 1.0 },
					resolution: { type: "v2", value: new THREE.Vector2() }
				};

	

				var size = 2.5;


					material = new THREE.ShaderMaterial( {

						uniforms: uniforms,
						vertexShader: document.getElementById( "vertexShader" ).textContent,
						fragmentShader: document.getElementById( "fragment_shader" ).textContent

						} );

					

					mesh = new THREE.Mesh( new THREE.SphereGeometry(  2,200,200), material );
					mesh.position.x = 0.0;
					mesh.position.y =  0.0;
					scene.add( mesh );

					

				

				renderer = new THREE.WebGLRenderer();
				container.appendChild( renderer.domElement );


				onWindowResize();

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize( event ) {

				uniforms.resolution.value.x = window.innerWidth;
				uniforms.resolution.value.y = window.innerHeight;


				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				var delta = clock.getDelta();     //距离上次绘制经过的时间（秒）

			
				uniforms.time.value = clock.elapsedTime;    //clock第一次调用getDelta后经过的时间（秒）
                controls.update();

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
