THREE.OBJLoader = function() {
	THREE.EventDispatcher.call(this)
}, THREE.OBJLoader.prototype = {
	constructor: THREE.OBJLoader,
	load: function(e, t) {
		var n = this,
			r = new XMLHttpRequest;
		r.addEventListener("load", function(e) {
			var r = n.parse(e.target.responseText);
			n.dispatchEvent({
				type: "load",
				content: r
			}), t && t(r)
		}, !1), r.addEventListener("progress", function(e) {
			n.dispatchEvent({
				type: "progress",
				loaded: e.loaded,
				total: e.total
			})
		}, !1), r.addEventListener("error", function() {
			n.dispatchEvent({
				type: "error",
				message: "Couldn't load URL [" + e + "]"
			})
		}, !1), r.open("GET", e, !0), r.send(null)
	},
	parse: function(e) {
		function t(e, t, n) {
			return new THREE.Vector3(e, t, n)
		}

		function n(e, t) {
			return new THREE.Vector2(e, t)
		}

		function r(e, t, n, r) {
			return new THREE.Face3(e, t, n, r)
		}

		function i(e, t, n, r, i) {
			return new THREE.Face4(e, t, n, r, i)
		}

		function s(e, t) {
			a.vertices.length > 0 && (a.mergeVertices(), a.computeCentroids(), a.computeFaceNormals(), a.computeBoundingSphere(), u.add(l), a = new THREE.Geometry, l = new THREE.Mesh(a, f), h = 0), e !== undefined && (l.name = e), t !== undefined && (f = new THREE.MeshLambertMaterial, f.name = t, l.material = f)
		}
		e = e.replace(/\ \\\r\n/g, "");
		var o = new THREE.Object3D,
			u = o,
			a = new THREE.Geometry,
			f = new THREE.MeshLambertMaterial,
			l = new THREE.Mesh(a, f),
			c = [],
			h = 0,
			p = [],
			d = [],
			v = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,
			m = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,
			g = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,
			y = /f( +\d+)( +\d+)( +\d+)( +\d+)?/,
			b = /f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/,
			w = /f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/,
			E = /f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/,
			S = e.split("\n");
		for (var x = 0; x < S.length; x++) {
			var T = S[x];
			T = T.trim();
			var N;
			if (T.length === 0 || T.charAt(0) === "#") continue;
			(N = v.exec(T)) !== null ? c.push(t(parseFloat(N[1]), parseFloat(N[2]), parseFloat(N[3]))) : (N = m.exec(T)) !== null ? p.push(t(parseFloat(N[1]), parseFloat(N[2]), parseFloat(N[3]))) : (N = g.exec(T)) !== null ? d.push(n(parseFloat(N[1]), parseFloat(N[2]))) : (N = y.exec(T)) !== null ? N[4] === undefined ? (a.vertices.push(c[parseInt(N[1]) - 1], c[parseInt(N[2]) - 1], c[parseInt(N[3]) - 1]), a.faces.push(r(h++, h++, h++))) : (a.vertices.push(c[parseInt(N[1]) - 1], c[parseInt(N[2]) - 1], c[parseInt(N[3]) - 1], c[parseInt(N[4]) - 1]), a.faces.push(i(h++, h++, h++, h++))) : (N = b.exec(T)) !== null ? N[10] === undefined ? (a.vertices.push(c[parseInt(N[2]) - 1], c[parseInt(N[5]) - 1], c[parseInt(N[8]) - 1]), a.faces.push(r(h++, h++, h++)), a.faceVertexUvs[0].push([d[parseInt(N[3]) - 1], d[parseInt(N[6]) - 1], d[parseInt(N[9]) - 1]])) : (a.vertices.push(c[parseInt(N[2]) - 1], c[parseInt(N[5]) - 1], c[parseInt(N[8]) - 1], c[parseInt(N[11]) - 1]), a.faces.push(i(h++, h++, h++, h++)), a.faceVertexUvs[0].push([d[parseInt(N[3]) - 1], d[parseInt(N[6]) - 1], d[parseInt(N[9]) - 1], d[parseInt(N[12]) - 1]])) : (N = w.exec(T)) !== null ? N[13] === undefined ? (a.vertices.push(c[parseInt(N[2]) - 1], c[parseInt(N[6]) - 1], c[parseInt(N[10]) - 1]), a.faces.push(r(h++, h++, h++, [p[parseInt(N[4]) - 1], p[parseInt(N[8]) - 1], p[parseInt(N[12]) - 1]])), a.faceVertexUvs[0].push([d[parseInt(N[3]) - 1], d[parseInt(N[7]) - 1], d[parseInt(N[11]) - 1]])) : (a.vertices.push(c[parseInt(N[2]) - 1], c[parseInt(N[6]) - 1], c[parseInt(N[10]) - 1], c[parseInt(N[14]) - 1]), a.faces.push(i(h++, h++, h++, h++, [p[parseInt(N[4]) - 1], p[parseInt(N[8]) - 1], p[parseInt(N[12]) - 1], p[parseInt(N[16]) - 1]])), a.faceVertexUvs[0].push([d[parseInt(N[3]) - 1], d[parseInt(N[7]) - 1], d[parseInt(N[11]) - 1], d[parseInt(N[15]) - 1]])) : (N = E.exec(T)) !== null ? N[10] === undefined ? (a.vertices.push(c[parseInt(N[2]) - 1], c[parseInt(N[5]) - 1], c[parseInt(N[8]) - 1]), a.faces.push(r(h++, h++, h++, [p[parseInt(N[3]) - 1], p[parseInt(N[6]) - 1], p[parseInt(N[9]) - 1]]))) : (a.vertices.push(c[parseInt(N[2]) - 1], c[parseInt(N[5]) - 1], c[parseInt(N[8]) - 1], c[parseInt(N[11]) - 1]), a.faces.push(i(h++, h++, h++, h++, [p[parseInt(N[3]) - 1], p[parseInt(N[6]) - 1], p[parseInt(N[9]) - 1], p[parseInt(N[12]) - 1]]))) : /^o /.test(T) ? (u = new THREE.Object3D, u.name = T.substring(2).trim(), o.add(u)) : /^g /.test(T) ? s(T.substring(2).trim(), undefined) : /^usemtl /.test(T) ? s(undefined, T.substring(7).trim()) : /^mtllib /.test(T) || /^s /.test(T)
		}
		return s(undefined, undefined), o
	}
}, THREE.MTLLoader = function(e, t) {
	THREE.EventDispatcher.call(this), this.baseUrl = e, this.options = t
}, THREE.MTLLoader.prototype = {
	load: function(e) {
		function r(n) {
			if (n.target.status === 200 || n.target.status === 0) {
				var r = t.parse(n.target.responseText);
				t.dispatchEvent({
					type: "load",
					content: r
				})
			} else t.dispatchEvent({
				type: "error",
				message: "Couldn't load URL [" + e + "]",
				response: n.target.responseText
			})
		}
		var t = this,
			n = new XMLHttpRequest;
		n.addEventListener("load", r, !1), n.addEventListener("progress", function(e) {
			t.dispatchEvent({
				type: "progress",
				loaded: e.loaded,
				total: e.total
			})
		}, !1), n.addEventListener("error", function() {
			t.dispatchEvent({
				type: "error",
				message: "Couldn't load URL [" + e + "]"
			})
		}, !1), n.open("GET", e, !0), n.send(null)
	},
	parse: function(e) {
		var t = e.split("\n"),
			n = {}, r = /\s+/,
			i = {};
		for (var s = 0; s < t.length; s++) {
			var o = t[s];
			o = o.trim();
			if (o.length === 0 || o.charAt(0) === "#") continue;
			var u = o.indexOf(" "),
				a = u >= 0 ? o.substring(0, u) : o;
			a = a.toLowerCase();
			var f = u >= 0 ? o.substring(u + 1) : "";
			f = f.trim();
			if (a === "newmtl") n = {
				name: f
			}, i[f] = n;
			else if (n)
				if (a === "ka" || a === "kd" || a === "ks") {
					var l = f.split(r, 3);
					n[a] = [parseFloat(l[0]), parseFloat(l[1]), parseFloat(l[2])]
				} else n[a] = f
		}
		var c = new THREE.MTLLoader.MaterialCreator(this.baseUrl, this.options);
		return c.setMaterials(i), c
	}
}, THREE.MTLLoader.MaterialCreator = function(e, t) {
	THREE.EventDispatcher.call(this), this.baseUrl = e, this.options = t, this.materialsInfo = {}, this.materials = {}, this.materialsArray = [], this.nameLookup = {}, this.side = this.options && this.options.side ? this.options.side : THREE.FrontSide, this.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping
}, THREE.MTLLoader.MaterialCreator.prototype = {
	setMaterials: function(e) {
		this.materialsInfo = this.convert(e), this.materials = {}, this.materialsArray = [], this.nameLookup = {}
	},
	convert: function(e) {
		if (!this.options) return e;
		var t = {};
		for (var n in e) {
			var r = e[n],
				i = {};
			t[n] = i;
			for (var s in r) {
				var o = !0,
					u = r[s],
					a = s.toLowerCase();
				switch (a) {
					case "kd":
					case "ka":
					case "ks":
						this.options && this.options.normalizeRGB && (u = [u[0] / 255, u[1] / 255, u[2] / 255]), this.options && this.options.ignoreZeroRGBs && u[0] === 0 && u[1] === 0 && u[1] === 0 && (o = !1);
						break;
					case "d":
						this.options && this.options.invertTransparency && (u = 1 - u);
						break;
					default:
				}
				o && (i[a] = u)
			}
		}
		return t
	},
	preload: function() {
		for (var e in this.materialsInfo) this.create(e)
	},
	getIndex: function(e) {
		return this.nameLookup[e]
	},
	getAsArray: function() {
		var e = 0;
		for (var t in this.materialsInfo) this.materialsArray[e] = this.create(t), this.nameLookup[t] = e, e++;
		return this.materialsArray
	},
	create: function(e) {
		return this.materials[e] === undefined && this.createMaterial_(e), this.materials[e]
	},
	createMaterial_: function(e) {
		var t = this.materialsInfo[e],
			n = {
				name: e,
				side: this.side
			};
		for (var r in t) {
			var i = t[r];
			switch (r.toLowerCase()) {
				case "kd":
					n.diffuse = (new THREE.Color).setRGB(i[0], i[1], i[2]);
					break;
				case "ka":
					n.ambient = (new THREE.Color).setRGB(i[0], i[1], i[2]);
					break;
				case "ks":
					n.specular = (new THREE.Color).setRGB(i[0], i[1], i[2]);
					break;
				case "map_kd":
					n.map = THREE.MTLLoader.loadTexture(this.baseUrl + i), n.map.wrapS = this.wrap, n.map.wrapT = this.wrap;
					break;
				case "ns":
					n.shininess = i;
					break;
				case "d":
					i < 1 && (n.transparent = !0, n.opacity = i);
					break;
				default:
			}
		}
		return n.diffuse && (n.ambient || (n.ambient = n.diffuse), n.color = n.diffuse), this.materials[e] = new THREE.MeshPhongMaterial(n), this.materials[e]
	}
}, THREE.MTLLoader.loadTexture = function(e, t, n, r) {
	var i = /\.dds$/i.test(e);
	if (i) var s = THREE.ImageUtils.loadCompressedTexture(e, t, n, r);
	else {
		var o = new Image,
			s = new THREE.Texture(o, t),
			u = new THREE.ImageLoader;
		u.addEventListener("load", function(e) {
			s.image = THREE.MTLLoader.ensurePowerOfTwo_(e.content), s.needsUpdate = !0, n && n(s)
		}), u.addEventListener("error", function(e) {
			r && r(e.message)
		}), u.crossOrigin = this.crossOrigin, u.load(e, o)
	}
	return s
}, THREE.MTLLoader.ensurePowerOfTwo_ = function(e) {
	if (!THREE.MTLLoader.isPowerOfTwo_(e.width) || !THREE.MTLLoader.isPowerOfTwo_(e.height)) {
		var t = document.createElement("canvas");
		t.width = THREE.MTLLoader.nextHighestPowerOfTwo_(e.width), t.height = THREE.MTLLoader.nextHighestPowerOfTwo_(e.height);
		var n = t.getContext("2d");
		return n.drawImage(e, 0, 0, e.width, e.height, 0, 0, t.width, t.height), t
	}
	return e
}, THREE.MTLLoader.isPowerOfTwo_ = function(e) {
	return (e & e - 1) === 0
}, THREE.MTLLoader.nextHighestPowerOfTwo_ = function(e) {
	--e;
	for (var t = 1; t < 32; t <<= 1) e |= e >> t;
	return e + 1
}, THREE.OBJMTLLoader = function() {
	THREE.EventDispatcher.call(this)
}, THREE.OBJMTLLoader.prototype = {
	constructor: THREE.OBJMTLLoader,
	load: function(e, t, n) {
		function f(n) {
			if (n.type === "load")
				if (n.content instanceof THREE.MTLLoader.MaterialCreator) s = !0, u = n.content, u.preload();
				else
			if (n.target.status === 200 || n.target.status === 0) {
				var i = n.target.responseText;
				t ? o = r.parse(i) : o = r.parse(i, function(e) {
					s = !1, a.load(a.baseUrl + e)
				})
			} else r.dispatchEvent({
				type: "error",
				message: "Couldn't load URL [" + e + "]",
				response: n.target.responseText
			});
			else n.type === "error" && (s = !0);
			s && o && (u && o.traverse(function(e) {
				if (e instanceof THREE.Mesh && e.material.name) {
					var t = u.create(e.material.name);
					t && (e.material = t)
				}
			}), r.dispatchEvent({
				type: "load",
				content: o
			}))
		}
		var r = this,
			i = new XMLHttpRequest,
			s, o, u, a = new THREE.MTLLoader(e.substr(0, e.lastIndexOf("/") + 1), n);
		a.addEventListener("load", f), a.addEventListener("error", f), t ? (a.load(t), s = !1) : s = !0, i.addEventListener("load", f, !1), i.addEventListener("progress", function(e) {
			r.dispatchEvent({
				type: "progress",
				loaded: e.loaded,
				total: e.total
			})
		}, !1), i.addEventListener("error", function() {
			r.dispatchEvent({
				type: "error",
				message: "Couldn't load URL [" + e + "]"
			})
		}, !1), i.open("GET", e, !0), i.send(null)
	},
	parse: function(e, t) {
		function n(e, t, n) {
			return new THREE.Vector3(e, t, n)
		}

		function r(e, t) {
			return new THREE.Vector2(e, t)
		}

		function i(e, t, n, r) {
			return new THREE.Face3(e, t, n, r)
		}

		function s(e, t, n, r, i) {
			return new THREE.Face4(e, t, n, r, i)
		}

		function o(e, t) {
			f.vertices.length > 0 && (f.mergeVertices(), f.computeCentroids(), f.computeFaceNormals(), f.computeBoundingSphere(), a.add(c), f = new THREE.Geometry, c = new THREE.Mesh(f, l), p = 0), e !== undefined && (c.name = e), t !== undefined && (l = new THREE.MeshLambertMaterial, l.name = t, c.material = l)
		}
		e = e.replace(/\ \\\r\n/g, "");
		var u = new THREE.Object3D,
			a = u,
			f = new THREE.Geometry,
			l = new THREE.MeshLambertMaterial,
			c = new THREE.Mesh(f, l),
			h = [],
			p = 0,
			d = [],
			v = [],
			m = /v( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,
			g = /vn( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,
			y = /vt( +[\d|\.|\+|\-|e]+)( +[\d|\.|\+|\-|e]+)/,
			b = /f( +\d+)( +\d+)( +\d+)( +\d+)?/,
			w = /f( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))( +(\d+)\/(\d+))?/,
			E = /f( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))( +(\d+)\/(\d+)\/(\d+))?/,
			S = /f( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))( +(\d+)\/\/(\d+))?/,
			x = e.split("\n");
		for (var T = 0; T < x.length; T++) {
			var N = x[T];
			N = N.trim();
			var C;
			if (N.length === 0 || N.charAt(0) === "#") continue;
			if ((C = m.exec(N)) !== null) h.push(n(parseFloat(C[1]), parseFloat(C[2]), parseFloat(C[3])));
			else if ((C = g.exec(N)) !== null) d.push(n(parseFloat(C[1]), parseFloat(C[2]), parseFloat(C[3])));
			else if ((C = y.exec(N)) !== null) v.push(r(parseFloat(C[1]), parseFloat(C[2])));
			else if ((C = b.exec(N)) !== null) C[4] === undefined ? (f.vertices.push(h[parseInt(C[1]) - 1], h[parseInt(C[2]) - 1], h[parseInt(C[3]) - 1]), f.faces.push(i(p++, p++, p++))) : (f.vertices.push(h[parseInt(C[1]) - 1], h[parseInt(C[2]) - 1], h[parseInt(C[3]) - 1], h[parseInt(C[4]) - 1]), f.faces.push(s(p++, p++, p++, p++)));
			else if ((C = w.exec(N)) !== null) C[10] === undefined ? (f.vertices.push(h[parseInt(C[2]) - 1], h[parseInt(C[5]) - 1], h[parseInt(C[8]) - 1]), f.faces.push(i(p++, p++, p++)), f.faceVertexUvs[0].push([v[parseInt(C[3]) - 1], v[parseInt(C[6]) - 1], v[parseInt(C[9]) - 1]])) : (f.vertices.push(h[parseInt(C[2]) - 1], h[parseInt(C[5]) - 1], h[parseInt(C[8]) - 1], h[parseInt(C[11]) - 1]), f.faces.push(s(p++, p++, p++, p++)), f.faceVertexUvs[0].push([v[parseInt(C[3]) - 1], v[parseInt(C[6]) - 1], v[parseInt(C[9]) - 1], v[parseInt(C[12]) - 1]]));
			else if ((C = E.exec(N)) !== null) C[13] === undefined ? (f.vertices.push(h[parseInt(C[2]) - 1], h[parseInt(C[6]) - 1], h[parseInt(C[10]) - 1]), f.faces.push(i(p++, p++, p++, [d[parseInt(C[4]) - 1], d[parseInt(C[8]) - 1], d[parseInt(C[12]) - 1]])), f.faceVertexUvs[0].push([v[parseInt(C[3]) - 1], v[parseInt(C[7]) - 1], v[parseInt(C[11]) - 1]])) : (f.vertices.push(h[parseInt(C[2]) - 1], h[parseInt(C[6]) - 1], h[parseInt(C[10]) - 1], h[parseInt(C[14]) - 1]), f.faces.push(s(p++, p++, p++, p++, [d[parseInt(C[4]) - 1], d[parseInt(C[8]) - 1], d[parseInt(C[12]) - 1], d[parseInt(C[16]) - 1]])), f.faceVertexUvs[0].push([v[parseInt(C[3]) - 1], v[parseInt(C[7]) - 1], v[parseInt(C[11]) - 1], v[parseInt(C[15]) - 1]]));
			else if ((C = S.exec(N)) !== null) C[10] === undefined ? (f.vertices.push(h[parseInt(C[2]) - 1], h[parseInt(C[5]) - 1], h[parseInt(C[8]) - 1]), f.faces.push(i(p++, p++, p++, [d[parseInt(C[3]) - 1], d[parseInt(C[6]) - 1], d[parseInt(C[9]) - 1]]))) : (f.vertices.push(h[parseInt(C[2]) - 1], h[parseInt(C[5]) - 1], h[parseInt(C[8]) - 1], h[parseInt(C[11]) - 1]), f.faces.push(s(p++, p++, p++, p++, [d[parseInt(C[3]) - 1], d[parseInt(C[6]) - 1], d[parseInt(C[9]) - 1], d[parseInt(C[12]) - 1]])));
			else if (/^o /.test(N)) a = new THREE.Object3D, a.name = N.substring(2).trim(), u.add(a);
			else if (/^g /.test(N)) o(N.substring(2).trim(), undefined);
			else if (/^usemtl /.test(N)) o(undefined, N.substring(7).trim());
			else if (/^mtllib /.test(N)) {
				if (t) {
					var k = N.substring(7);
					k = k.trim(), t(k)
				}
			} else /^s /.test(N) || console.log("THREE.OBJMTLLoader: Unhandled line " + N)
		}
		return o(undefined, undefined), u
	}
}, THREE.OrbitControls = function(e, t, n) {
	function b() {
		return 2 * Math.PI / 60 / 60 * r.autoRotateSpeed
	}

	function w() {
		return Math.pow(.95, r.userZoomSpeed)
	}

	function E(e) {
		if (!r.enabled) return;
		if (!r.userRotate) return;
		e.button === 0 ? (g = m.ROTATE, o.set(e.clientX, e.clientY)) : e.button === 1 ? (g = m.ZOOM, f.set(e.clientX, e.clientY)) : e.button === 2 && (g = m.PAN), document.addEventListener("mousemove", S, !1), document.addEventListener("mouseup", x, !1)
	}

	function S(e) {
		if (!r.enabled) return;
		e.preventDefault();
		if (g === m.ROTATE) u.set(e.clientX, e.clientY), a.subVectors(u, o), r.rotateLeft(2 * Math.PI * a.x / s * r.userRotateSpeed), r.rotateUp(2 * Math.PI * a.y / s * r.userRotateSpeed), o.copy(u);
		else if (g === m.ZOOM) l.set(e.clientX, e.clientY), c.subVectors(l, f), c.y > 0 ? r.zoomIn() : r.zoomOut(), f.copy(l);
		else if (g === m.PAN) {
			var t = e.movementX || e.mozMovementX || e.webkitMovementX || 0,
				n = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
			r.pan(new THREE.Vector3(-t, n, 0))
		}
	}

	function x(e) {
		if (!r.enabled) return;
		if (!r.userRotate) return;
		document.removeEventListener("mousemove", S, !1), document.removeEventListener("mouseup", x, !1), g = m.NONE
	}

	function T(e) {
		if (!r.enabled) return;
		if (!r.userZoom) return;
		var t = 0;
		e.wheelDelta ? t = e.wheelDelta : e.detail && (t = -e.detail), t > 0 ? r.zoomOut() : r.zoomIn(), e.preventDefault()
	}

	function N(e) {
		if (!r.enabled) return;
		if (!r.userPan) return;
		var t = !0;
		switch (e.keyCode) {
			case r.keys.UP:
				r.pan(new THREE.Vector3(0, 1, 0));
				break;
			case r.keys.BOTTOM:
				r.pan(new THREE.Vector3(0, -1, 0));
				break;
			case r.keys.LEFT:
				r.pan(new THREE.Vector3(-1, 0, 0));
				break;
			case r.keys.RIGHT:
				r.pan(new THREE.Vector3(1, 0, 0));
				break;
			default:
				t = !1
		}
		t && e.preventDefault()
	}
	THREE.EventDispatcher.call(this), this.enabled = !0, this.object = e, this.domElement = t !== undefined ? t : document, this.center = new THREE.Vector3, this.userZoom = !0, this.userZoomSpeed = 1, this.userRotate = !0, this.userRotateSpeed = 1, this.userPan = !0, this.userPanSpeed = 2, this.autoRotate = !1, this.autoRotateSpeed = 2, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minDistance = 0, this.maxDistance = Infinity, this.keys = {
		LEFT: 37,
		UP: 38,
		RIGHT: 39,
		BOTTOM: 40
	};
	var r = this,
		i = 1e-6,
		s = 1800,
		o = new THREE.Vector2,
		u = new THREE.Vector2,
		a = new THREE.Vector2,
		f = new THREE.Vector2,
		l = new THREE.Vector2,
		c = new THREE.Vector2,
		h = 0,
		p = 0,
		d = 1,
		v = new THREE.Vector3,
		m = {
			NONE: -1,
			ROTATE: 0,
			ZOOM: 1,
			PAN: 2
		}, g = m.NONE,
		y = {
			type: "change"
		};
	this.changeCamera = function(e) {
		this.object = e, this.center = e.direction || new THREE.Vector3
	}, this.rotateLeft = function(e) {
		e === undefined && (e = b()), p -= e
	}, this.rotateRight = function(e) {
		e === undefined && (e = b()), p += e
	}, this.rotateUp = function(e) {
		e === undefined && (e = b()), h -= e
	}, this.rotateDown = function(e) {
		e === undefined && (e = b()), h += e
	}, this.zoomIn = function(e) {
		e === undefined && (e = w()), d /= e
	}, this.zoomOut = function(e) {
		e === undefined && (e = w()), d *= e
	}, this.pan = function(e) {
		e.transformDirection(this.object.matrix), e.multiplyScalar(r.userPanSpeed), this.object.position.add(e), this.center.add(e)
	}, this.update = function() {
		var e = this.object.position,
			t = e.clone().sub(this.center = this.object.direction || this.center),
			n = Math.atan2(t.x, t.z),
			r = Math.atan2(Math.sqrt(t.x * t.x + t.z * t.z), t.y);
		this.autoRotate && this.rotateLeft(b()), n += p, r += h, r = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, r)), r = Math.max(i, Math.min(Math.PI - i, r));
		var s = t.length() * d;
		s = Math.max(this.minDistance, Math.min(this.maxDistance, s)), t.x = s * Math.sin(r) * Math.sin(n), t.y = s * Math.cos(r), t.z = s * Math.sin(r) * Math.cos(n), e.copy(this.center).add(t), this.object.lookAt(this.center), p = 0, h = 0, d = 1, v.distanceTo(this.object.position) > 0 && (this.dispatchEvent(y), v.copy(this.object.position))
	}, this.domElement.addEventListener("contextmenu", function(e) {
		e.target === this && e.preventDefault()
	}, !1), this.domElement.addEventListener("mousedown", E, !1), this.domElement.addEventListener("mousewheel", T, !1), this.domElement.addEventListener("DOMMouseScroll", T, !1), this.domElement.setAttribute("tabindex", -1), this.domElement.addEventListener("keydown", N, !1)
},
function(e) {
	var t = {
		cfg: {
			layout: null,
			open: !0,
			usecontrol: !0,
			cameraLight: !1,
			addGrid: !0,
			beforeload: null,
			onloading: null,
			onload: null,
			obj: "",
			mtl: "",
			map: "",
			scene: {
				angle: 60,
				aspect: 1,
				near: 1,
				far: 2e3
			}
		},
		loadCfg: {
			obj: "",
			mtl: "",
			map: "",
			cover: !0,
			id: null,
			beforeload: null,
			onloading: null,
			onload: null
		}
	}, n = function(e) {
			return this.cfg = r.extend(r.clone(t.cfg), e, !0), this.scene = new THREE.Scene, this.renderer = new THREE.WebGLRenderer, this.camera = this.pointLight = this.controls = null, this.objs = new THREE.Object3D, this.loadQueue = this.loader = [], this.oldObjs = [], this.isloading = this.isRunning = !1, this.addObjId = 0, this._off = !this.cfg.open, this.init(), this
		};
	n.prototype = {
		init: function() {
			function u() {
				return i.renderer.render(i.scene, i.camera), i.cfg.cameraLight && (i.pointLight.position = i.camera.position), i
			}
			var e = this.cfg.scene.aspect,
				t = this.cfg.layout,
				n = r.getDomstyle(t),
				i = this;
			e == 1 && (this.cfg.scene.aspect = n.p);
			var s = this.cfg.scene;
			this.camera = new THREE.PerspectiveCamera(s.angle, s.aspect, s.near, s.far), this.camera.position.set(0, 20, 300), this.scene.add(new THREE.AmbientLight(8947848));
			var o = new THREE.DirectionalLight(16777215);
			return o.position.set(1, 1, 1), this.scene.add(o), this.cfg.cameraLight && (this.pointLight = new THREE.PointLight(16777215), this.scene.add(this.pointLight)), this.objs.id = "PreviewObjs", this.scene.add(this.objs), this.loader = [new THREE.OBJMTLLoader, new THREE.OBJLoader], r.each(this.loader, function(e, t) {
				t.addEventListener("load", function(e) {
					var t = e.content,
						n = i.loadQueue.shift();
					t.id = n.id || "ZK" + i.addObjId++;
					if (n.cover)
						while (i.objs.children.length > 0) i.objs.remove(i.objs.children[0]);
					n.onloading && e.target.removeEventListener("progress", n.onloadingFixed, !1), i.cfg.usecontrol && (i.controls.center.set(0, 0, 0), i.camera.position.set(0, 20, 300)), i.objs.add(t), n.map && i.addTextureImg(t, n.map), i.loadtheQueue(), u(), !i.isRunning && (i.isRunning = !0) && i.animate(), i.cfg.onload && i.cfg.onload.call(i, t), n.onload && n.onload.call(i, t)
				}), i.cfg.onloading && t.addEventListener("progress", function(e) {
					i.cfg.onloading.call(i, e.loaded, e.total)
				}, !1)
			}), this.renderer.setSize(n.x, n.y), this.cfg.layout.appendChild(this.renderer.domElement), this.cfg.usecontrol && (this.renderer.domElement.style.position = "relative", r.noSelect(this.renderer.domElement), this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement), this.controls.addEventListener("change", u)), this.cfg.addGrid && this.addGrid(), this.render = u, this.cfg.obj && this.load({
				obj: this.cfg.obj,
				mtl: this.cfg.mtl,
				map: this.cfg.map
			}), this
		},
		clear: function() {
			var e = this.objs.children.slice(0);
			while (this.objs.children.length > 0) this.objs.remove(this.objs.children[0]);
			return this.render(), e
		},
		add: function(e) {
			if (r.type(e) == "array")
				for (var t = 0; t < e.length; t++) this.add(e[t]);
			return this.objs.add(e), this
		},
		load: function(e) {
			return e = r.extend(r.clone(t.loadCfg), e), e.obj ? (this.loadQueue.push(e), this.isloading || this.loadtheQueue(), this) : this
		},
		loadtheQueue: function() {
			if (!this.loadQueue.length) return this.isloading = !1, this;
			this.isloading = !0;
			var e = this.loadQueue[0],
				t = this,
				n = e.obj && e.mtl ? this.loader[0] : this.loader[1];
			return this.cfg.beforeload && this.cfg.beforeload.call(this), e.beforeload && e.beforeload.call(this), e.onloading && (e.onloadingFixed = function(t) {
				e.onloading(t.loaded, t.total)
			}, n.addEventListener("progress", e.onloadingFixed, !1)), e.obj && e.mtl ? n.load(e.obj, e.mtl) : n.load(e.obj), this
		},
		addTextureImg: function(e, t) {
			var n = new THREE.ImageLoader,
				r = new THREE.Texture,
				i = this;
			return n.addEventListener("load", function(e) {
				r.image = e.content, r.needsUpdate = !0, i.render(), delete(n = null)
			}), n.load(t), e.traverse(function(e) {
				e instanceof THREE.Mesh && (e.material.map = r)
			}), this
		},
		render: null,
		animate: function() {
			var e = this;
			return e.isRunning = !0, this._off ? this : (this.cfg.usecontrol && this.controls.update(), this.render(), requestAnimationFrame(function() {
				e.animate()
			}), this)
		},
		addGrid: function(e, t, n) {
			var r = new THREE.LineBasicMaterial({
				color: 16777215
			}),
				i = new THREE.Geometry;
			e = e || -0.04, t = n || 50, n = n || 1e3;
			for (var s = 0; s <= n / t * 2; s++) i.vertices.push(new THREE.Vector3(-n, e, s * t - n)), i.vertices.push(new THREE.Vector3(n, e, s * t - n)), i.vertices.push(new THREE.Vector3(s * t - n, e, -n)), i.vertices.push(new THREE.Vector3(s * t - n, e, n));
			var o = new THREE.Line(i, r, THREE.LinePieces);
			o.id = "ZKfloor", this.scene.add(o)
		},
		off: function() {
			return this._off = !0, this
		},
		open: function() {
			return this._off = !1, this.animate(), this
		}
	};
	var r = {
		dom: function(t, n) {
			n = n || e.document;
			var r = [],
				i = t.charAt(0),
				s = t.substr(1),
				o;
			if (i == "#") return n.getElementById(s);
			if (i == ".") {
				o = n.getElementsByClassName(s);
				for (var u = 0; u < o.length; u++) r.push(o[u])
			} else {
				o = n.getElementsByTagName(t);
				for (var u = 0; u < o.length; u++) r.push(o[u])
			}
			return r
		},
		each: function(e, t) {
			var n, r, i, s = this.type(e);
			if (s == "object")
				for (n in e) {
					r = e[n], i = t.call(r, n, r);
					if (i === !1) break
				} else if (s == "array")
					for (var o = 0; o < e.length; o++) {
						r = e[o], i = t.call(r, o, r);
						if (i === !1) break
					}
		},
		type: function(e) {
			if (e == null) return "null";
			var t = Object.prototype.toString.call(e).split(" ");
			return t.length < 2 ? "object" : t[1].substr(0, t[1].length - 1).toLowerCase()
		},
		haskey: function(e) {
			var t = this.type(e);
			if (t == "array") return !!e.length;
			if (t == "object")
				for (var n in e) return !0;
			return !1
		},
		extend: function(e, t, n) {
			var i, s, o, u, a = this.type(t),
				n = !! n;
			if (a == "object")
				for (o in t) n && o in e && r.haskey(e[o]) ? r.extend(e[o], t[o], n) : e[o] = t[o];
			else if (a == "array")
				for (o = 0; o < t.length; o++) n && o in e && r.haskey(e[o]) ? r.extend(e[o], t[o], n) : e[o] = t[o];
			return e
		},
		clone: function(e) {
			var t, n = r.type(e) == "array" ? [] : {}, t, n, i = r.type(e);
			if (i == "array") return e.slice(0);
			if (i == "object")
				for (t in e) n[t] = e[t];
			else n = e;
			return n
		},
		getDomstyle: function(t) {
			var n = {};
			return n.y = parseInt(e.getComputedStyle(t, null).getPropertyValue("height")), n.x = parseInt(e.getComputedStyle(t, null).getPropertyValue("width")), n.p = n.x / n.y, n
		},
		noSelect: function(e) {
			e.style.webkitUserSelect = "none", e.style.mozUserSelect = "none", e.style.userSelect = "none"
		}
	};
	n.$ = r, e.Preview = n
}(window)