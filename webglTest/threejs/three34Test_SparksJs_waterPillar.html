<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - particles - shapes</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				color: #aaa;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="67/three.js"></script>

		<script src="Tween.js"></script>
		<script src="Sparks.js"></script>
		<script src="Pillar.js"></script>

		<script src="CopyShader.js"></script>
		<script src="FilmShader.js"></script>
		<script src="FocusShader.js"></script>
		<script src="HorizontalBlurShader.js"></script>
		<script src="TriangleBlurShader.js"></script>
		<script src="VerticalBlurShader.js"></script>
		<script src="ColorifyShader.js"></script>

		<script src="EffectComposer.js"></script>
		<script src="RenderPass.js"></script>
		<script src="ShaderPass.js"></script>
		<script src="MaskPass.js"></script>
		<script src="BloomPass.js"></script>
		<script src="FilmPass.js"></script>

		<script type="x-shader/x-vertex" id="vertexshader">

				attribute float size;
				attribute vec3 pcolor;

				varying vec3 vColor;

				void main() {

					vColor = pcolor;

					vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

					gl_PointSize = size * ( 200.0 / length( mvPosition.xyz ) );

					gl_Position = projectionMatrix * mvPosition;

				}

			</script>

			<script type="x-shader/x-fragment" id="fragmentshader">

				uniform sampler2D texture;

				varying vec3 vColor;

				void main() {

					vec4 outColor = texture2D( texture, gl_PointCoord );

					gl_FragColor = outColor * vec4( vColor, 1.0 );
					

				}

			</script>

		<script>

			var container;

			var camera, scene, renderer, controls;

			var speed = 50;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var delta = 1, clock = new THREE.Clock();

			var particleCloud, sparksEmitter, emitterPos;

			var composer;
			var effectBlurX, effectBlurY, hblur, vblur;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// CAMERA

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set( 0, 150, 400 );
               

				// SCENE

				scene = new THREE.Scene();


				// Create particle objects for Three.js

				var particlesLength = 2000;

				var particles = new THREE.Geometry();

				var Pool = {
					__pools: [],
					get: function() {
						if ( this.__pools.length > 0 ) {
							return this.__pools.pop();
						}
						console.log( "pool ran out!" )
						return null;
					},
					// Release a vector back into the pool
					add: function( v ) {
						this.__pools.push( v );
					}
				};

				for ( i = 0; i < particlesLength; i ++ ) {

					particles.vertices.push( new THREE.Vector3(0, 0, 0) );
					Pool.add( i );

				}

				attributes = {

					size:  { type: 'f', value: [] },
					pcolor: { type: 'c', value: [] }

				};

				var sprite = generateSprite() ;

				texture = new THREE.Texture( sprite );
				texture.needsUpdate = true;

				uniforms = {

					texture:   { type: "t", value: texture }

				};

				var shaderMaterial = new THREE.ShaderMaterial( {
					uniforms: 		uniforms,
					attributes:     attributes,
					vertexShader:   document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					blending: 		THREE.AdditiveBlending,
					depthWrite:		false,
					transparent:	true
				});

				particleCloud = new THREE.ParticleSystem( particles, shaderMaterial );

                particleCloud.dynamic = true;
				particleCloud.sortParticles = true;

				var vertices = particleCloud.geometry.vertices;
				var values_size = attributes.size.value;
				var values_color = attributes.pcolor.value;

				for( var v = 0; v < vertices.length; v ++ ) {
					values_size[ v ] = 50;
					values_color[ v ] = new THREE.Color( 0x000000 );
					particles.vertices[ v ].set( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );
				}

		

				// EMITTER STUFF
				
				var setTargetParticle = function() {
					var target = Pool.get();
					return target;
				};
                
				var onParticleCreated = function( p ) {
					var position = p.position;
					var target = p.target;
					if ( target ) {
						particles.vertices[ target ] = p.position;
						values_color[ target ].setHSL( 1, 1, 1 );
					};
				};

				var onParticleDead = function( particle ) {
					var target = particle.target;
					if ( target ) {
						values_color[ target ].setRGB( 0, 0, 0 );
						particles.vertices[ target ].set( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );
						Pool.add( particle.target );
					}
				};

				sparksEmitter = new SPARKS.Emitter( new SPARKS.SteadyCounter( 500 ) );  //每秒创建的离子数
				emitterpos = new THREE.Vector3( 0, 100, 0 );
				sparksEmitter.addInitializer( new SPARKS.Position( new SPARKS.PointZone( emitterpos ) ) );  //设置初始位置，PointZone从指定点开始
				sparksEmitter.addInitializer( new SPARKS.Lifetime(2, 2.1 ));  //粒子存在时间（单位秒）
				sparksEmitter.addInitializer( new SPARKS.Target( null, setTargetParticle ) );   //初始化时运行回调函数, 并设置回调函数的结果为 the particle's target.
				sparksEmitter.addInitializer( new SPARKS.Velocity( new SPARKS.PointZone( new THREE.Vector3( 0, -50, 0 ) ) ) ); //设置速度
				sparksEmitter.addAction( new SPARKS.Age() ); //handle the lifetime of each particle
				sparksEmitter.addAction( new SPARKS.Accelerate( 0, -98, 0) ); //设置一个运动的加速度
				sparksEmitter.addAction( new SPARKS.Move() ); //使粒子运动
				sparksEmitter.addAction( new SPARKS.RandomDrift( 90, 10, 0 ) );   //粒子位置的最大摆动

				sparksEmitter.addCallback( SPARKS.EVENT_PARTICLE_CREATED, onParticleCreated );
				sparksEmitter.addCallback( SPARKS.EVENT_PARTICLE_DEAD, onParticleDead );
				sparksEmitter.start();
				// End Particles
                
                		scene.add( particleCloud );
                    pillar = new THREE.Pillar(emitterpos, 50, new THREE.Color( 0x000000 ), 2, 90);
                   // scene.add(pillar);
                    
                
                //renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor( 0x000000, 1 );
				container.appendChild( renderer.domElement );
	

				// POST PROCESSING
				var effectFocus = new THREE.ShaderPass( THREE.FocusShader );
				var effectCopy = new THREE.ShaderPass( THREE.CopyShader );
				effectFilm = new THREE.FilmPass( 0.5, 0.25, 2048, false );
                
                var colorify = new THREE.ShaderPass( THREE.ColorifyShader );
                    colorify.uniforms.color.value.setHex( "0x5E89CB" );
                    
				var shaderBlur = THREE.TriangleBlurShader;
				effectBlurX = new THREE.ShaderPass( shaderBlur, 'texture' );
				effectBlurY = new THREE.ShaderPass( shaderBlur, 'texture' );

				var radius = 15;
				var blurAmountX = radius / window.innerWidth;
				var blurAmountY = radius / window.innerHeight;

				hblur = new THREE.ShaderPass( THREE.HorizontalBlurShader );
				vblur = new THREE.ShaderPass( THREE.VerticalBlurShader);

				hblur.uniforms[ 'h' ].value =  1 / window.innerWidth;
				vblur.uniforms[ 'v' ].value =  1 / window.innerHeight;

				effectBlurX.uniforms[ 'delta' ].value = new THREE.Vector2( blurAmountX, 0 );
				effectBlurY.uniforms[ 'delta' ].value = new THREE.Vector2( 0, blurAmountY );

				effectFocus.uniforms[ 'sampleDistance' ].value = 0.99; //0.94
				effectFocus.uniforms[ 'waveFactor' ].value = 0.003;  //0.00125

				var renderScene = new THREE.RenderPass( scene, camera );

				composer = new THREE.EffectComposer( renderer );
				composer.addPass( renderScene );
			//	composer.addPass( hblur );
			//	composer.addPass( vblur );
			// composer.addPass( effectBlurX );
			//	composer.addPass( effectBlurY );
			//	 composer.addPass( effectCopy );
			// composer.addPass( effectFocus );
			// composer.addPass( effectFilm );
			 composer.addPass( colorify );
				vblur.renderToScreen = true;
				effectBlurY.renderToScreen = true;
				effectFocus.renderToScreen = true;
				effectCopy.renderToScreen = true;
				effectFilm.renderToScreen = true;
				colorify.renderToScreen = true;
                
				window.addEventListener( 'resize', onWindowResize, false );
			}

			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				hblur.uniforms[ 'h' ].value =  1 / window.innerWidth;
				vblur.uniforms[ 'v' ].value =  1 / window.innerHeight;
				var radius = 15;
				var blurAmountX = radius / window.innerWidth;
				var blurAmountY = radius / window.innerHeight;
				effectBlurX.uniforms[ 'delta' ].value = new THREE.Vector2( blurAmountX, 0 );
				effectBlurY.uniforms[ 'delta' ].value = new THREE.Vector2( 0, blurAmountY );
				composer.reset();
			}

				function generateSprite() {
					var canvas = document.createElement( 'canvas' );
					canvas.width = 128;
					canvas.height = 128;
					var context = canvas.getContext( '2d' );
					context.beginPath();
					context.arc( 64, 64, 60, 0, Math.PI * 2, false) ;
					context.lineWidth = 0.5; //0.05
					context.stroke();
					context.restore();
					var gradient = context.createRadialGradient( canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2 );
	//				gradient.addColorStop( 0, 'rgba(255, 255, 255, 1)' );
	//				gradient.addColorStop( 0.2, 'rgba(0, 238, 255, 0.8)' );
	//				gradient.addColorStop( 0.4, 'rgba(0, 59, 70, 0.5)' );
	//				gradient.addColorStop( 1, 'rgba(0, 0, 0, 1)' );
    
    				gradient.addColorStop( 0, 'rgba(255, 255, 255, 1)' );
					gradient.addColorStop( 0.2, 'rgba(60, 164, 236, 0.8)' );
					gradient.addColorStop( 0.4, 'rgba(0, 64, 136, 0.5)' );
					gradient.addColorStop( 1, 'rgba(0, 0, 0, 0)' );
					context.fillStyle = gradient;
					context.fill();
					return canvas;
				}

			function animate() {
				requestAnimationFrame( animate );
				render();		
			}

			function render() {
				delta = speed * clock.getDelta();
				particleCloud.geometry.verticesNeedUpdate = true;
				attributes.size.needsUpdate = true;
				attributes.pcolor.needsUpdate = true;
                
                pillar.geometry.verticesNeedUpdate = true;
               pillar.geometry.colorsNeedUpdate = true;
                
                camera.lookAt(scene.position);
				renderer.clear();
			//	 renderer.render( scene, camera );
				composer.render( 0.1 );
			}

		</script>

	</body>
</html>
