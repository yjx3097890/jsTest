<!DOCTYPE html>

<html>

<head>
	<title>Rigid body - Physijs</title>
	

	
	<script type="text/javascript" src="67/three.js"></script>
	<script type="text/javascript" src="physi.js"></script>
	<script type="text/javascript" src="OBJLoader.js"></script>
            <script type="text/javascript" src="TrackballControls.js"></script>
	<script type="text/javascript">
	
	'use strict';
	
	Physijs.scripts.worker = 'physijs_worker.js';
	Physijs.scripts.ammo = 'ammo.js';
	
	var initScene, render, applyForce, setMousePosition, mouse_position, geometry,controls,
		ground_material, box_material,
		projector, renderer, scene, ground, light, camera, box, boxes = [];
	
	initScene = function() {
		projector = new THREE.Projector;
		
		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;
		document.getElementById( 'viewport' ).appendChild( renderer.domElement );
		
		scene = new Physijs.Scene({reportSize:20, broadphase:"dynamic", fixedTimeStep: 1/ 60});
		scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
        //物理模拟后执行
		scene.addEventListener(
			'update',
			function() {
			//	applyForce();
				scene.simulate( undefined, 5 );  
			}
		);
		
		camera = new THREE.PerspectiveCamera(
			35,
			window.innerWidth / window.innerHeight,
			1,
			1000
		);
		camera.position.set( 60, 50, 60 );
		camera.lookAt( scene.position );
            controls = cameraControl(camera);
		scene.add( camera );
		
		// Light
		light = new THREE.DirectionalLight( 0xFFFFFF );
		light.position.set( 20, 40, -15 );
		light.target.position.copy( scene.position );
		light.castShadow = true;
		light.shadowCameraLeft = -60;
		light.shadowCameraTop = -60;
		light.shadowCameraRight = 60;
		light.shadowCameraBottom = 60;
		light.shadowCameraNear = 20;
		light.shadowCameraFar = 200;
		light.shadowBias = -.0001
		light.shadowMapWidth = light.shadowMapHeight = 2048;
		light.shadowDarkness = .7;
		scene.add( light );
		
		// Materials
		ground_material = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'rocks.jpg' ) }),
			0.9, // high friction  摩擦系数
			0.2 // low restitution  弹性系数
		);
		ground_material.map.wrapS = ground_material.map.wrapT = THREE.RepeatWrapping;
		ground_material.map.repeat.set( 4, 4 );
		
		box_material = Physijs.createMaterial(
			new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture( 'plywood.jpg' ) }),
			0.9, // low friction
			0.2 // high restitution
		);
		box_material.map.wrapS = ground_material.map.wrapT = THREE.RepeatWrapping;
		box_material.map.repeat.set( 1.25, 1.25 );
		
		// Ground
        
		ground = new Physijs.BoxMesh(
			new THREE.CubeGeometry(11, 1.1, 11),
			ground_material,
			0 // mass 表示无限不会动
		);
		ground.receiveShadow = true;
        
        var wall1 = new Physijs.BoxMesh(
			new THREE.CubeGeometry(11, 2, 16),
			ground_material,
			0 // mass 表示无限不会动
		); 
        wall1.rotation.x = - Math.PI / 2;
        wall1.position.y = 7;
        wall1.position.z = -5;
        wall1.visible = false;
        
        ground.add(wall1);  

        var wall2 = new Physijs.BoxMesh(
                new THREE.CubeGeometry(11, 2, 16),
                ground_material,
                0 // mass 表示无限不会动
        );
        wall2.position.z = 5;
        wall2.rotation.x = - Math.PI / 2;
        wall2.position.y = 7;
        wall2.visible = false;
        ground.add(wall2);   

        var wall3 = new Physijs.BoxMesh(
                new THREE.CubeGeometry(11, 2, 16),
                ground_material,
                0 // mass 表示无限不会动
        );
        wall3.rotation.z= - Math.PI / 2;
        wall3.rotation.x= - Math.PI / 2;
        wall3.position.z = 0;
        wall3.position.y = 7;
        wall3.position.x = -5;
        wall3.visible = false;
        ground.add(wall3);
        
        var wall4 = new Physijs.BoxMesh(
                new THREE.CubeGeometry(11, 2, 16),
                ground_material,
                0 // mass 表示无限不会动
        );
        wall4.rotation.z= - Math.PI / 2;
        wall4.rotation.x= - Math.PI / 2;
        wall4.position.z = 0;
        wall4.position.x = 5;
        wall4.position.y = 7;
        wall4.visible = false;
        ground.add(wall4);

        ground.visible = false;
		scene.add( ground );
        
        	var loader = new THREE.OBJLoader();
				loader.load( 'cup-half.obj', function ( object ) {
          
                    var cube = object.children[0];
                    cube.position.set(0, 7, 0);
                    cube.scale.set(10, 10, 10);
                     cube.material.transparent = true;
                    cube.material.opacity = 0.5;
                    
					scene.add( cube );

				} );

     createObj(Math.random*5);
        setInterval(function(){createObj(Math.random*5);},1000);
		
		
		renderer.domElement.addEventListener( 'mousemove', setMousePosition );

		 render();

	};
	
    function createObj() {
                var r = 1;
           


                    geometry = new THREE.OctahedronGeometry(r* (0.5*Math.random()+0.5), 1);   //八面体
        
			box = new Physijs.SphereMesh(
				geometry,
				box_material,
                1 + Math.random() * 10
			);

			box.position.set(
				Math.random() ,
				10 + Math.random() * 5,
				Math.random() 
			);
			box.rotation.set(
				Math.random() * Math.PI * 2,
				Math.random() * Math.PI * 2,
				Math.random() * Math.PI * 2
			);
			box.scale.set(
				0.5*Math.random()  + 0.5,
                0.5*Math.random()  + 0.5,
                0.5*Math.random() + 0.5
			);
			box.castShadow = true;
			scene.add( box );
			boxes.push( box );

		
    }
    
	render = function() {
		requestAnimationFrame( render );
        scene.simulate();
        controls.update();
		renderer.render( scene, camera );
	};
	
	setMousePosition = function( evt ) {
		// Find where mouse cursor intersects the ground plane
		var vector = new THREE.Vector3(
			( evt.clientX / renderer.domElement.clientWidth ) * 2 - 1,
			-( ( evt.clientY / renderer.domElement.clientHeight ) * 2 - 1 ),
			.5
		);
		projector.unprojectVector( vector, camera );
		vector.sub( camera.position ).normalize();
		if(box){
        
		var coefficient = (box.position.y - camera.position.y) / vector.y
		mouse_position = camera.position.clone().add( vector.multiplyScalar( coefficient ) );
        }
	};
	
	applyForce = function() {
		if (!mouse_position) return;
		var strength = 50, distance, effect, offset, box;
		
		for ( var i = 0; i < boxes.length; i++ ) {
			box = boxes[i];
			distance = mouse_position.distanceTo( box.position ),
			effect = mouse_position.clone().sub( box.position ).normalize().multiplyScalar( strength / distance ).negate(),
			offset = mouse_position.clone().sub( box.position );
			box.applyImpulse( effect, offset );
		}
	};
	
	window.onload = initScene;
	
     function cameraControl(camera){
                   var controls = new THREE.TrackballControls( camera );
                
                    //旋转速度
                    controls.rotateSpeed = 1.0;
                    //变焦速度
                    controls.zoomSpeed = 1.2;
                    //平移速度
                    controls.panSpeed = 0.8;
                    //是否不变焦
                    controls.noZoom = false;
                    //是否不平移
                    controls.noPan = true;
                    //可能是惯性 true没有惯性
                    controls.staticMoving = false;
                    //动态阻尼系数 就是灵敏度
                    controls.dynamicDampingFactor = 0.3;
                    
                    return controls;
         }

	</script>
</head>

<body>

	<div id="viewport"></div>
</body>

</html>
