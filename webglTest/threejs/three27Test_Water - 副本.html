<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - cube refraction [Lucy]</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#000;
				color:#fff;
				padding:0;
				margin:0;
				overflow:hidden;
				font-family:georgia;
				text-align:center;
			}

		</style>
	</head>

	<body>
	
    	<script type="x-shader/x-vertex" id="vertexshader">
             
            varying vec2 coord;
            void main() {
              coord = position.xy * 0.5 + 0.5;
              gl_Position = vec4(position.xyz, 1.0);
            }
			

		</script>
  
        
		<script type="x-shader/x-fragment" id="drop-fragmentshader">

			    const float PI = 3.141592653589793;
                uniform sampler2D texture;
                uniform vec2 center;
                uniform float radius;
                uniform float strength;
                varying vec2 coord;
                void main() {
                  /* get vertex info */
                  vec4 info = texture2D(texture, coord);
                  
                  /* add the drop to the height */
                  float drop = max(0.0, 1.0 - length(center * 0.5 + 0.5 - coord) / radius);
                  drop = 0.5 - cos(drop * PI) * 0.5;
                  info.r += drop * strength;
                  
                  gl_FragColor = info;
                }

		</script>
        
		<script type="x-shader/x-fragment" id="update-fragmentshader">
               uniform sampler2D texture;
            uniform vec2 delta;
            varying vec2 coord;
            void main() {
              /* get vertex info */
              vec4 info = texture2D(texture, coord);
              
              /* calculate average neighbor height */
              vec2 dx = vec2(delta.x, 0.0);
              vec2 dy = vec2(0.0, delta.y);
              float average = (
                texture2D(texture, coord - dx).r +
                texture2D(texture, coord - dy).r +
                texture2D(texture, coord + dx).r +
                texture2D(texture, coord + dy).r
              ) * 0.25;
              
              /* change the velocity to move toward the average */
              info.g += (average - info.r) * 2.0;
              
              /* attenuate the velocity a little so waves do not last forever */
              info.g *= 0.995;
              
              /* move the vertex along the velocity */
              info.r += info.g;
              
              gl_FragColor = info;
    }
    </script>
    
    <script type="x-shader/x-fragment" id="normal-fragmentshader">
        uniform sampler2D texture;
        uniform vec2 delta;
        varying vec2 coord;
        void main() {
          /* get vertex info */
          vec4 info = texture2D(texture, coord);
          
          /* update the normal */
          vec3 dx = vec3(delta.x, texture2D(texture, vec2(coord.x + delta.x, coord.y)).r - info.r, 0.0);
          vec3 dy = vec3(0.0, texture2D(texture, vec2(coord.x, coord.y + delta.y)).r - info.r, delta.y);
          info.ba = normalize(cross(dy, dx)).xz;
          
          gl_FragColor = info;
        }
   </script>
    
         <script type="x-shader/x-vertex" id="water-vertexshader">
              uniform sampler2D water;
              varying vec3 vPosition;
              varying vec2 vUv;
              void main() {
                vec4 info = texture2D(water, uv);
                vUv = uv;
                vPosition = position.xzy;
                vPosition.y += info.r;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.0);
              }
        </script>
        
        <script type="x-shader/x-fragment" id="water-fragmentshader">        
          
   const float IOR_AIR = 1.0;
  const float IOR_WATER = 1.333;
  const vec3 abovewaterColor = vec3(0.25, 1.0, 1.25);
  const vec3 underwaterColor = vec3(0.4, 0.9, 1.0);
  const float poolHeight = 1.0;
  uniform vec3 light;
  uniform sampler2D tiles;
  uniform sampler2D causticTex;
  uniform sampler2D water;
  
  vec2 intersectCube(vec3 origin, vec3 ray, vec3 cubeMin, vec3 cubeMax) {
    vec3 tMin = (cubeMin - origin) / ray;  //时间
    vec3 tMax = (cubeMax - origin) / ray;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return vec2(tNear, tFar);
  }
  
  vec3 getWallColor(vec3 point) {  // point墙壁上的点
    float scale = 0.5;
    
    vec3 wallColor;
    vec3 normal;
    if (abs(point.x) > 0.999) {
        //左右墙壁
      wallColor = texture2D(tiles, point.yz * 0.5 + vec2(1.0, 0.5)).rgb;
      normal = vec3(-point.x, 0.0, 0.0);
    } else if (abs(point.z) > 0.999) {
        //前后墙壁
      wallColor = texture2D(tiles, point.yx * 0.5 + vec2(1.0, 0.5)).rgb;
      normal = vec3(0.0, 0.0, -point.z);
    } else {
        //水下墙壁
    
      wallColor = texture2D(tiles, point.xz * 0.5 + 0.5).rgb;
      normal = vec3(0.0, 1.0, 0.0);
    }
    
    scale /= length(point); /* pool ambient occlusion */
    
    /* caustics */  //水下焦散光线
    vec3 refractedLight = -refract(-light, vec3(0.0, 1.0, 0.0), IOR_AIR / IOR_WATER);
    float diffuse = max(0.0, dot(refractedLight, normal));
    vec4 info = texture2D(water, point.xz * 0.5 + 0.5);
   if (point.y < info.r) {
        //水池水下部分
     vec4 caustic = texture2D(causticTex, 0.75 * (point.xz - point.y * refractedLight.xz / refractedLight.y) * 0.5 + 0.5);
      scale += diffuse * caustic.r * 2.0 * caustic.g;
    } else {
      /* shadow for the rim of the pool */   //水池边,未接触水
     vec2 t = intersectCube(point, refractedLight, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
     diffuse *= 1.0 / (1.0 + exp(-200.0 / (1.0 + 10.0 * (t.y - t.x)) * (point.y + refractedLight.y * t.y - 2.0 / 12.0)));
      
      scale += diffuse * 0.5;
    }
    
    return wallColor * scale;
  }
          
          
          
          
                
          uniform vec3 eye;
         varying vec3 vPosition;
            varying vec2 vUv;
      uniform samplerCube sky;
      //获得水面颜色
      vec3 getSurfaceRayColor(vec3 origin, vec3 ray, vec3 waterColor) {
        vec3 color;
        if (ray.y < 0.0) {
        //水中墙壁颜色
          vec2 t = intersectCube(origin, ray, vec3(-1.0, -poolHeight, -1.0), vec3(1.0, 2.0, 1.0));
        color = getWallColor(origin + ray * t.y);
        } else {
         
            //天空倒影
           color = textureCube(sky, ray).rgb;
            color += vec3(pow(max(0.0, dot(light, ray)), 5000.0)) * vec3(10.0, 8.0, 6.0);
        }
       if (ray.y < 0.0) color *= waterColor;
        return color;
      }
      
      void main() {
       vec2 coord = vUv;
        vec4 info = texture2D(water, coord);
        
        /* make water look more "peaked" */
        for (int i = 0; i < 5; i++) {
         coord += info.ba * 0.005;
         info = texture2D(water, coord);
        }
        
        vec3 normal = vec3(info.b, sqrt(1.0 - dot(info.ba, info.ba)), info.a);
        vec3 incomingRay = normalize(vPosition - eye);
            vec3 reflectedRay = reflect(incomingRay, normal);        //反射光线
          vec3 refractedRay = refract(incomingRay, normal, IOR_AIR / IOR_WATER);      //折射光线  
          float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));
          
          vec3 reflectedColor = getSurfaceRayColor(vPosition, reflectedRay, abovewaterColor);
          vec3 refractedColor = getSurfaceRayColor(vPosition, refractedRay, abovewaterColor);
          
          gl_FragColor = vec4(mix(refractedColor, reflectedColor, fresnel), 1.0);

} 
      
        </script>
             
             
        <script type="x-shader/x-vertex" id="cup-vertexshader">
       
            varying vec2 vUv;
            varying vec3 vmPosition;
            varying float show;
            void main() {
                vUv = uv;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); 
                vmPosition = mvPosition.xyz;
                gl_Position = projectionMatrix * mvPosition;
                
                if(dot(position, normal) < 0.0 ){
                    show = 1.0;
                }else{
                    show = -1.0;
                }
            } 
			

		</script>
 
        <script type="x-shader/x-fragment" id="cup-fragmentshader">
            precision mediump float;
            
  //          uniform float waterY;
  //          uniform vec3 waterColor;
  //          uniform samplerCube sky;
            
            varying vec3 vmPosition;
            varying vec2 vUv;
            varying float show;
            void main() {
            
                if( show >= 0.0) {
                    gl_FragColor = vec4(0.1);
                }else{
                    discard;
                }
      /**           float fresnel = mix(0.25, 1.0, pow(1.0 - dot(normal, -incomingRay), 3.0));
                     vec3 reflectedColor = getSurfaceRayColor(vPosition, reflectedRay, abovewaterColor);
                    vec3 refractedColor = getSurfaceRayColor(vPosition, refractedRay, abovewaterColor);
                    vec3 color = mix(refractedColor, reflectedColor, fresnel);
                    if(vmPosition.y > waterY){
                        gl_FragColor = vec4(color, 1.0);
                    } else {
                        gl_FragColor = vec4();
                    }
        */            
            }
			

		</script>
        
        
		<script src="67/three.js"></script>
        <script src="OBJLoader.js"></script>
        <script type="text/javascript" src="TrackballControls.js"></script>
        
        <script src="CopyShader.js"></script>
        <script src="ConvolutionShader.js"></script>
    
		<script src="EffectComposer.js"></script>
		<script src="ShaderPass.js"></script>
		<script src="MaskPass.js"></script>
		<script src="RenderPass.js"></script>
		<script>

			var container, controls;

			var camera, scene, sceneRestrict, cupScene, waterScene, renderer, projector;

			var mesh, material, geometry, cup, cupRestrict, waterMaterial;

			var uniforms, attributes;

			var renderTargetA, renderTargetB, composer;

			var windowHalfX = window.innerWidth / 2,
			windowHalfY = window.innerHeight / 2,
			mouse = {},
			intersect;

			init();
			animate();

			function init() {

				container = document.createElement('div');
				document.body.appendChild(container);

				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
				camera.position.set(0, 1, 5);
				controls = cameraControl(camera);

				scene = new THREE.Scene();
				waterScene = new THREE.Scene();
				sceneRestrict = new THREE.Scene();
                cupScene = new THREE.Scene();
				// LIGHTS

				var ambient = new THREE.AmbientLight(0x9C9C9C);
				cupScene.add(ambient);

				var directionalLight = new THREE.DirectionalLight(0xffeedd, 0.2);
				directionalLight.position.set(0, 0, 1).normalize();
					 	cupScene.add( directionalLight );

				//RrnderTarget
				var params = {
					minFilter : THREE.LinearFilter,
					magFilter : THREE.LinearFilter,
					format : THREE.RGBAFormat,
					stencilBuffer : false
				};
				renderTargetA = new THREE.WebGLRenderTarget(1024, 1024, params);
				renderTargetB = new THREE.WebGLRenderTarget(1024, 1024, params);

				//material
				var r = "beach/",
				urls = [r + "nx.jpg", r + "px.jpg",
					r + "py.jpg", r + "py.jpg",
					r + "pz.jpg", r + "nz.jpg"];
				var skyCube = THREE.ImageUtils.loadTextureCube(urls, new THREE.CubeRefractionMapping());
				var tiles = THREE.ImageUtils.loadTexture("tiles.jpg");
				tiles.wrapS = tiles.wrapT = THREE.RepeatWrapping;
				tiles.minFilter = THREE.LinearMipMapLinearFilter;
				tiles.format = THREE.RGBFormat;

				uniforms = {
					light : {
						type : "v3",
						value : new THREE.Vector3()
					},
					eye : {
						type : "v3",
						value : new THREE.Vector3()
					},
					tiles : {
						type : "t",
						value : null
					},
					water : {
						type : "t",
						value : null
					},
					causticTex : {
						type : "t",
						value : null
					},
					sky : {
						type : "t",
						value : skyCube
					}
				};
				material = new THREE.ShaderMaterial({
					//	uniforms : uniforms,
						vertexShader : document.getElementById('cup-vertexshader').textContent,
						fragmentShader : document.getElementById('cup-fragmentshader').textContent
					});

				waterMaterial = new THREE.MeshBasicMaterial({
						color : 0x3C6EBA,
			//			envMap : skyCube,
				 		side : THREE.FrontSide,
                         transparent :　true,
                        opacity : 0.2
                  
					});

				//geometry
				geometry = new THREE.PlaneGeometry(8, 8);
				geometry.dynamic = true;

				// mesh
				mesh = new THREE.Mesh(geometry, waterMaterial);
				mesh.rotation.x =  - Math.PI / 2;
				mesh.position.y = -0.0;
				waterScene.add(mesh);

				//cup
				var texture = THREE.ImageUtils.loadTexture("glass.jpg");
				texture.needsUpdate = true;

				var loader = new THREE.OBJLoader();
				loader.load('cup.obj', function (object) {

					object.traverse(function (child) {
						if (child instanceof THREE.Mesh) {
          
                            
							child.material.transparent = true;
							child.material.opacity = 0.3;
                           child.material.envMap = skyCube;
                            child.material.refractionRatio = 0.85;
                     
                     // child.material.depthWrite = false;
	 				}
					});
					cup = object.children[0];
                    cup.position.y = -0.3;
					//默认点(0, -0.7, 0)在烧杯底部圆心
                    
					cupRestrict = cup.clone();
                   cupRestrict.material = material;
				
                    
			 	 	cupScene.add(cup);
                    sceneRestrict.add(cupRestrict);

				});

				//render
				renderer = new THREE.WebGLRenderer();
				renderer.autoClear = false;
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);

				//postprocessing
				var rtParams = {
					minFilter : THREE.LinearFilter,
					magFilter : THREE.LinearFilter,
					format : THREE.RGBFormat,
					stencilBuffer : true
				};
				var render = new THREE.RenderPass(scene, camera);
				var waterRender = new THREE.RenderPass(waterScene, camera);
				waterRender.clear = false;
				var restrictRender = new THREE.RenderPass(sceneRestrict, camera);
				var cupRender = new THREE.RenderPass(cupScene, camera);
                cupRender.clear = false;
				var clearMask = new THREE.ClearMaskPass();
				var renderMask = new THREE.MaskPass(sceneRestrict, camera);
				//     renderMask.inverse = true;
				var copyPass = new THREE.ShaderPass(THREE.CopyShader);
				copyPass.renderToScreen = true;

				composer = new THREE.EffectComposer(renderer, new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams));

                
				composer.addPass(render);
				composer.addPass(renderMask);
				composer.addPass(waterRender);
				composer.addPass(clearMask);
				composer.addPass(cupRender);
				composer.addPass(copyPass);

				//屏幕和场景转换工具
				projector = new THREE.Projector();

				//event
				window.addEventListener('resize', onWindowResize, false);
				renderer.domElement.addEventListener("mousedown", onMouseDown, false);
				renderer.domElement.addEventListener("mousemove", onMouseMove, false);
				renderer.domElement.addEventListener("mouseup", onMouseUp, false);
				window.addEventListener("keydown", onKeyDown, false);

				uniforms.light.value.set(2.0, 2.0, -1.0).normalize();

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2,
				windowHalfY = window.innerHeight / 2,

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

			}

			var oldX, oldY, mode;
			function onMouseDown(event) {
				event.preventDefault();
				if (!mouse.x) {
					onMouseMove(event);
					return;
				}

				if (intersect.length > 0) {
					oldX = mouse.x;
					oldY = mouse.y;
					mode = "moveCup";
					controls.enabled = false;
				} else {

					controls.enabled = true;

				}
			}

			function onMouseMove(event) {
				event.preventDefault();

				mouse.x = event.clientX / windowHalfX - 1;
				mouse.y =  - event.clientY / windowHalfY + 1;

				var vector = new THREE.Vector3(mouse.x, mouse.y, 0);
				//把这个向量从屏幕转化为场景中的向量
				projector.unprojectVector(vector, camera);

				//新建一条从相机的位置到vector向量的一道光线
				var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
				intersect = raycaster.intersectObject(cup);

				if (intersect.length > 0 || mode == "moveCup") {

					container.style.cursor = "pointer";

				} else {

					container.style.cursor = "auto";

				}

				if (mode == "moveCup") {

					cup.rotation.z += (oldX - mouse.x) * 0.5;
					cup.rotation.x += (oldY - mouse.y) * 0.5;
                    
                    cupRestrict.rotation.copy(cup.rotation);
                    
					oldX = mouse.x;
					oldY = mouse.y;

				}
			}

			function onMouseUp(event) {
				event.preventDefault();
				mode = "moveCamera";
				controls.enabled = true;

			}

			function onKeyDown(event) {
				switch (event.keyCode) {
				case 32:
					controls.reset();
					break;
				default:
					return;
				}
			}

			function animate() {

				requestAnimationFrame(animate);

				render();

			}

			function render() {

				controls.update();

				//   uniforms.eye.value.copy(camera.position);

				//		renderer.render( scene, camera );

				renderer.clear();
      //          composer.reset();
				composer.render();
			}

			function cameraControl(camera) {
				var controls = new THREE.TrackballControls(camera);

				//旋转速度
				controls.rotateSpeed = 1.0;
				//变焦速度
				controls.zoomSpeed = 1.2;
				//平移速度
				controls.panSpeed = 0.8;
				//是否不变焦
				controls.noZoom = false;
				//是否不平移
				controls.noPan = true;
				//可能是惯性 true没有惯性
				controls.staticMoving = false;
				//动态阻尼系数 就是灵敏度
				controls.dynamicDampingFactor = 0.3;

				return controls;
			}

		</script>

	</body>
</html>
