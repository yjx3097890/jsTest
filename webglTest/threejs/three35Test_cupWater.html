<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - cube refraction [Lucy]</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#000;
				color:#fff;
				padding:0;
				margin:0;
				overflow:hidden;
				font-family:georgia;
				text-align:center;
			}

		</style>
	</head>

	<body>
             
        <script type="x-shader/x-vertex" id="cup-vertexshader">
            
            varying vec2 vUv;
            varying float show;
            void main() {
                vUv = uv;
                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); 
                gl_Position = projectionMatrix * mvPosition;
                
                if(dot(position, normal) < 0.0){
                    show = 1.0;
                }else{
                    show = -1.0;
                }
            } 
			

		</script>
 
        <script type="x-shader/x-fragment" id="cup-fragmentshader">
            precision mediump float;
             uniform vec3 color;
            varying vec2 vUv;
            varying float show;
            void main() {
            
                if( show >= 0.0 ) {
                    gl_FragColor = vec4(0.27, 0.43, 0.73, 0.3);
                }else{
                    discard;
                }
            }
			

		</script>
        
        
		<script src="three.js"></script>
        <script src="OBJLoader.js"></script>
        <script type="text/javascript" src="TrackballControls1.js"></script>
        
         <script src="Tween.js"></script>
		<script src="Sparks.js"></script>
		<script src="Pillar.js"></script>
        
        <script src="CopyShader.js"></script>
        <script src="ConvolutionShader.js"></script>
        <script src="ColorifyShader.js"></script>
        
		<script src="EffectComposer.js"></script>
		<script src="ShaderPass.js"></script>
		<script src="MaskPass.js"></script>
		<script src="RenderPass.js"></script>
		<script>

			var container, controls;

			var camera, scene, sceneRestrict, cupScene, waterScene, renderer, projector;

			var water1, water2, restrictMaterial, waterGeometry, cup1, cupRestrict1, cup2, cupRestrict2, waterMaterial, waterPillar,waterCubeLength;

			var uniforms, attributes;

			var renderTargetA, renderTargetB, composer;

			var windowHalfX = window.innerWidth / 2,
			windowHalfY = window.innerHeight / 2,
			mouse = {},
			intersect;
            
            var height1 = 1.0,
             height2 = 0.3,
             rotation1 = 0,
           cupPosition1 = new THREE.Vector3(0, 4.2, 0),
           cupPosition2 = new THREE.Vector3(1.1, -3, 0),
           pillarPosition = cupPosition1.clone().add(new THREE.Vector3(0.8, 0.8, 0)),
           delta = 0;

			init();
			animate();

			function init() {

				container = document.createElement('div');
				document.body.appendChild(container);

				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 10000);
				camera.position.set(0, 4, 8);
                camera.lookAt(new THREE.Vector3(0,0,0));
				controls = cameraControl(camera);

				scene = new THREE.Scene();
				waterScene = new THREE.Scene();
				sceneRestrict = new THREE.Scene();
                cupScene = new THREE.Scene();
				// LIGHTS

				var ambient = new THREE.AmbientLight(0x9C9C9C);
			  	cupScene.add(ambient);
                
				var directionalLight = new THREE.DirectionalLight(0xffeedd, 1.6);
				directionalLight.position.set(0, 0, 1).normalize();
                
				cupScene.add( directionalLight );

				//waterCube
				waterMaterial = new THREE.MeshBasicMaterial({
						color : 0x5E89CB,		
				 		side : THREE.FrontSide,
                         transparent : false,
                        opacity : 0.3,
                        depthTest:true
					});
                waterCubeLength = 4;
				waterGeometry = new THREE.CubeGeometry(waterCubeLength, waterCubeLength, waterCubeLength);
				waterGeometry.dynamic = true;

                        // water1
				water1 = new THREE.Mesh(waterGeometry, waterMaterial);
				water1.position.y = cupPosition1.y + height1 - 0.7 - waterCubeLength/2; 
                // water2
				water2 = new THREE.Mesh(waterGeometry, waterMaterial);
				water2.position.y = cupPosition2.y + height2 - 0.7 - waterCubeLength/2;
                water2.position.x = cupPosition2.x;
                
				waterScene.add(water1);
				waterScene.add(water2);

                
				//cup
                var r = "beach/",
				urls = [r + "nx.jpg", r + "px.jpg",
					r + "py.jpg", r + "py.jpg",
					r + "pz.jpg", r + "nz.jpg"];
				var skyCube = THREE.ImageUtils.loadTextureCube(urls, new THREE.CubeRefractionMapping());

				uniforms = {
					color : {
						type : "c",
						value : new THREE.Color(0x5E89CB)
					},
                    height : {
                        type : "f",
                        value : 0
                    }
				};
				restrictMaterial = new THREE.ShaderMaterial({
						uniforms : uniforms,
						vertexShader : document.getElementById('cup-vertexshader').textContent,
						fragmentShader : document.getElementById('cup-fragmentshader').textContent
					});
                
				var loader = new THREE.OBJLoader();
				loader.load('cup.obj', function (object) {

					object.traverse(function (child) {
						if (child instanceof THREE.Mesh) {
                            
							child.material.transparent = true;
							child.material.opacity = 0.3;
                            child.material.envMap = skyCube;
                            child.material.refractionRatio = 0.85;
    
                        }
					});
                    //默认点(0, -0.7, 0)在烧杯底部圆心 ,烧杯高1.55， 嘴半径0.8
                    //cup1
					cup1 = object.children[0];
                    cup1.position.copy(cupPosition1);
                    
					cupRestrict1 = cup1.clone();
                    cupRestrict1.material = restrictMaterial;
                    //cup2
                    cup2 = cup1.clone();
                    cup2.position.copy(cupPosition2);
                    
                    cupRestrict2 = cup2.clone();
                    cupRestrict2.material = restrictMaterial;
              
			 	 	cupScene.add(cup1);
                    sceneRestrict.add(cupRestrict1);
                    cupScene.add(cup2);
                    sceneRestrict.add(cupRestrict2);
                    
              //      scene.add(cup1);
                  //  scene.add(cup2);

				});
                
                
                //waterPillar
                     hiddernP = new THREE.Vector3(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
                    waterPillar = new THREE.Pillar(pillarPosition.clone(), 0.1, new THREE.Color( 0x3666A7 ), 1.16, 1.4);
                	
                    scene.add(waterPillar);
                    
				//render
				renderer = new THREE.WebGLRenderer();
				renderer.autoClear = false;
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);

				//postprocessing
				var rtParams = {
					minFilter : THREE.LinearFilter,
					magFilter : THREE.LinearFilter,
					format : THREE.RGBFormat,
					stencilBuffer : true
				};
				var render = new THREE.RenderPass(scene, camera);
				var waterRender = new THREE.RenderPass(waterScene, camera);
				waterRender.clear = false;
				var restrictRender = new THREE.RenderPass(sceneRestrict, camera);
				var cupRender = new THREE.RenderPass(cupScene, camera);
                cupRender.clear = false;
				var clearMask = new THREE.ClearMaskPass();
				var renderMask = new THREE.MaskPass(sceneRestrict, camera);
                var pillarMask = new THREE.MaskPass(waterScene, camera);
				var copyPass = new THREE.ShaderPass(THREE.CopyShader);
				copyPass.renderToScreen = true;
                var colorify = new THREE.ShaderPass( THREE.ColorifyShader );
                colorify.uniforms.color.value.setHex(  0x3666A7 );
                
				composer = new THREE.EffectComposer(renderer, new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, rtParams));
                
				composer.addPass(render);
		//		composer.addPass(restrictRender);
				composer.addPass(cupRender);
				composer.addPass(renderMask);
				composer.addPass(waterRender);
				composer.addPass(clearMask);
				composer.addPass(copyPass);

				//屏幕和场景转换工具
				projector = new THREE.Projector();

				//event
				window.addEventListener('resize', onWindowResize, false);
				renderer.domElement.addEventListener("mousedown", onMouseDown, false);
				renderer.domElement.addEventListener("mousemove", onMouseMove, false);
				renderer.domElement.addEventListener("mouseup", onMouseUp, false);
				window.addEventListener("keydown", onKeyDown, false);


			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2,
				windowHalfY = window.innerHeight / 2,

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

			}

			var oldX, oldY, mode;
			function onMouseDown(event) {
				event.preventDefault();
				if (!mouse.x) {
					onMouseMove(event);
					return;
				}

				if (intersect.length > 0) {
					oldX = mouse.x;
					oldY = mouse.y;
					mode = "moveCup";
					controls.enabled = false;
				} else {

					controls.enabled = true;

				}
			}

			function onMouseMove(event) {
				event.preventDefault();

				mouse.x = event.clientX / windowHalfX - 1;
				mouse.y =  - event.clientY / windowHalfY + 1;

				var vector = new THREE.Vector3(mouse.x, mouse.y, 0);
				//把这个向量从屏幕转化为场景中的向量
				projector.unprojectVector(vector, camera);

				//新建一条从相机的位置到vector向量的一道光线
				var raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());
				intersect = raycaster.intersectObject(cup1);

				if (intersect.length > 0 || mode == "moveCup") {

					container.style.cursor = "pointer";

				} else {

					container.style.cursor = "auto";

				}

				if (mode == "moveCup") {

					cup1.rotation.z += (oldX - mouse.x) ;
					cup1.rotation.z += -(oldY - mouse.y);
                    
                    cupRestrict1.rotation.copy(cup1.rotation);
                    rotation1 = cup1.rotation.z;
                    if ( rotation1 < 0 ) {
                        pillarPosition = cupPosition1.clone().add(new THREE.Vector3(0.8 * Math.sqrt(2) * Math.cos(Math.PI/4 + rotation1),0.8 * Math.sqrt(2) * Math.sin(Math.PI/4 + rotation1), 0));
                    }else{
                        pillarPosition = cupPosition1.clone().add(new THREE.Vector3(0.8 * Math.sqrt(2) * Math.cos(Math.PI* 3 / 4 + rotation1),0.8 * Math.sqrt(2) * Math.sin(Math.PI*3/4 + rotation1), 0));
                    }
					oldX = mouse.x;
					oldY = mouse.y;

				} 
       
			}

			function onMouseUp(event) {
				event.preventDefault();
				mode = "moveCamera";
				controls.enabled = true;

			}

			function onKeyDown(event) {
				switch (event.keyCode) {
				case 32:
					controls.reset();
					break;
				default:
					return;
				}
			}

			function animate() {

				requestAnimationFrame(animate);

				render();

			}

			function render() {
                waterPillar.geometry.verticesNeedUpdate = true;
                waterPillar.geometry.colorsNeedUpdate = true;
                waterPillar.material.needUpdates = true;
                
                if(pillarPosition.y < water1.position.y + waterCubeLength/2  ){
                
                    if(delta < 0) {
                        delta = water1.position.y + waterCubeLength/2 - pillarPosition.y;
                    }else{
                          delta += water1.position.y + waterCubeLength/2 - pillarPosition.y;
                    }
                    water1.position.y = pillarPosition.y - waterCubeLength/2;
                }else if ( pillarPosition.y === water1.position.y + waterCubeLength/2 && delta >=0 ) {
                     if (delta > 0.04) {
                        delta -= 0.005;
                     
                     }else if(delta > 0.02){
                        delta -= 0.0002;
                     
                     }else if(delta >= 0){
                        delta -= 0.0001;
                     }
                }else{
                    delta = -1;
                }
                
                if (delta > 0.04) {
                     waterPillar.args.position.copy(pillarPosition);
                    waterPillar.material.size = 0.4;
                    water2.position.y += 0.003;
                }else if(delta > 0.02){
                     waterPillar.args.position.copy(pillarPosition);
                    waterPillar.material.size = 0.2;
                    water2.position.y += 0.002;
                }else if (delta > 0 ) {
                    waterPillar.args.position.copy(pillarPosition);
                    waterPillar.material.size = 0.1;
                    water2.position.y += 0.001; 
                }else{
                     waterPillar.args.position.copy(hiddernP);
                }
                
                if(water2.position.y >= height1+height2 + cupPosition2.y - 0.7 - waterCubeLength/2) {
                    water2.position.y = height1+height2 + cupPosition2.y - 0.7 - waterCubeLength/2;
                    water1.position.y = 1.2;
                }
                
                
               controls.update();
				renderer.clear();
				composer.render(); 
			}
            

			function cameraControl(camera) {
				var controls = new THREE.TrackballControls(camera);

				//旋转速度
				controls.rotateSpeed = 0.8;
				//变焦速度
				controls.zoomSpeed = 1.2;
				//平移速度
				controls.panSpeed = 0.8;
				//是否不变焦
				controls.noZoom = false;
				//是否不平移,鼠标右键平移
				controls.noPan = false;
				//可能是惯性 true没有惯性
				controls.staticMoving = true;
				//动态阻尼系数 就是灵敏度
				controls.dynamicDampingFactor = 0.3;
                
        //        controls.noRotate = true;
                
                controls.noRoll = false;
             
               
                
                
				return controls;
			}

		</script>

	</body>
</html>
